{
  "docusaurus-plugin-content-blog": {
    "default": {
      "blogSidebarTitle": "所有文章",
      "blogPosts": [
        {
          "id": "sourcemap",
          "metadata": {
            "permalink": "/sourcemap",
            "source": "@site/blog/sourcemap/index.md",
            "title": "SourceMap格式详解",
            "description": "之前都是借助浏览器直接使用SourceMap，只知道里面储存着位置信息，来将压缩混淆后的代码还原回压缩混淆前的代码，但对其具体格式并不了解。因为笔者近期在对NEJ打包脚本做升级，希望只保留NEJ对代码模块依赖分析的部分，对于代码编译引入Babel，对于代码混淆则引入UglifyJS 3的版本。因此必须对SourceMap格式做详细的了解，以实现SourceMap经过Babel，UglifyJS，文件合并后，依然能保持正确，实现代码的反混淆。",
            "date": "2022-09-30T18:00:00.000Z",
            "formattedDate": "2022年9月30日",
            "tags": [
              {
                "label": "sourcemap",
                "permalink": "/tags/sourcemap"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 7.365,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "sourcemap",
              "title": "SourceMap格式详解",
              "authors": "auver",
              "date": "2022-09-30T18:00",
              "tags": [
                "sourcemap",
                "javascript"
              ],
              "image": "https://i.imgur.com/mErPwqL.png"
            },
            "unlisted": false,
            "nextItem": {
              "title": "Babel插件指南",
              "permalink": "/babel-plugin"
            }
          },
          "content": "之前都是借助浏览器直接使用SourceMap，只知道里面储存着位置信息，来将压缩混淆后的代码还原回压缩混淆前的代码，但对其具体格式并不了解。因为笔者近期在对NEJ打包脚本做升级，希望只保留NEJ对代码模块依赖分析的部分，对于代码编译引入Babel，对于代码混淆则引入UglifyJS 3的版本。因此必须对SourceMap格式做详细的了解，以实现SourceMap经过Babel，UglifyJS，文件合并后，依然能保持正确，实现代码的反混淆。\n\n# 如何告知SourceMap文件地址\n\n在JS文件底部，增加一行注释\n\n```\n//# sourceMappingURL=/path/to/file.js.map\n```\n\n或者设置特殊的 HTTP HEADER\n\n```\nSourceMap: /path/to/file.js.map\nX-SourceMap: /path/to/file.js.map (deprecated)\n```   \n\n<!-- truncate -->\n\n# SourceMap格式\n\n```\n{\n    \"version\": 3,\n    \"sources\": [\"a.js\", \"b.js\"],\n    \"names\": [\"foo\", \"bar\"],\n    \"mappings\": \"gBAAA,MAAOA,IAAP,KAAgB,KAAhB,CACA,GAAMC,IAAG,QAAGD,GAAH,WAAGA,GAAH,sBAAGA,GAAG,CAAEE,MAAR,+BAAG,iBAAAF,GAAG,CAAf\",\n    \"file\": \"out.js\",\n    \"sourceRoot\": \"../src\",\n    \"sourcesContent\": [\"...\", \"...\"]\n}\n```\n\n* names\n    转换前的所有变量名和属性名，在mappings中，会使用这些名称在数组中的索引来进行查找。\n* mappings\n    记录位置信息的字符串，后面会继续介绍\n* file\n    (可选) 转换后的文件名称\n* sourceRoot\n   (可选) 转换前的文件所在的目录\n* sources\n    转换前的文件地址（相对于sourceRoot）。为数组，因为可能存在多个源文件合并为一个文件。\n* sourcesContent\n    (可选) 转换前的文件内容。即每一个源文件中源代码的内容。\n    \n    也就是说，如果未提供 `sourcesContent`，那么就需要基于 `sourceRoot` + `sources` 得到转换前的文件地址，通过访问源文件得到源代码的内容。\n    \n# mappings\n    \n笔者之前比较困惑的一点，怎么把混淆后的变量名和属性名，和 names 中列举的转换前的变量名和属性名一一对应起来。\n\n其实这个位置信息是完全靠 mappings 来提供的。（即names中的顺序完全是可以和混淆后变量出现的顺序不同，在mappings中，会使用这些名称在数组中的索引来进行查找）至于为什么单独提供 names 而不是 mappings，完全是从节省文件大小的角度来设计的。\n\nmappings不仅仅用于表示混淆前后的变量名和属性名映射关系，也是记录了混淆前后的位置对应关系。因为像Babel预编译等工具，会对源文件的语句做变更、插入新语句等的调整，工具本身也是在尽量将关联的编译前后的语句进行映射。\n\n简而言之，mappings中每块信息，其实描述的是：\n\n在转换后的代码第`m`行第`n`列，它在转换前的代码中是sources中的第`i`个文件的第`j`行第`k`列。如果它是变量名或属性名，转换前的名称是 names 中的第`x`个。即包含5个或6个数字（`x`可能没有）\n\n`[m, n, i, j, k, [x]]`\n\n而实际的mappings为了节省文件大小，有以下设计：\n\n* 以分号（;）来区分转换后代码的不同行。即，第一个分号前的内容，就对应转换后代码的第一行，以此类推，第`m`个分号前的内容，对应转换后代码的第`m`行；\n* 以逗号（,）分隔开的每一个内容，表示转换后代码的某处`位置`，采用VLQ编码。该内容在`,`相隔的文本在出现的顺序，与其在代码中的坐标信息无关。\n* VLQ编码中存储了多个数字，用来表示剩余的`坐标`信息和对应的转换前的源码代码`坐标`等，按顺序应当分别为：转换后位于代码的第`n`列；在转换前的代码中是sources中的第`i`个文件；在转换前的代码中是第`j`行；在转换前的代码中是第`k`列；如果它是变量名或属性名，转换前的名称是 names 中的第`x`个。\n* 对于转换后的代码第`n`列，转换前的代码中是sources中的第`i`个文件的第`j`行第`k`列，这几个`坐标`信息，在编码为VLQ前，还做了特殊处理，即这些`坐标`使用的是相对于上一个`位置`中这几个`坐标`的相对值。\n\n至于 VLQ 编码的编码、解码方式，此处不做解析。\n\n我们在实际阅读 mappings 时，可以借助 [https://www.murzwin.com/base64vlq.html](https://www.murzwin.com/base64vlq.html) 提供的工具进行转换。\n\n以如下代码为例，转换前：\n```js\nimport foo from 'foo';\nconst bar = foo?.method?.(true);\n```\n\n转换后：\n```js\nvar _foo$method;import foo from\"foo\";var bar=null===foo||void 0===foo||null===(_foo$method=foo.method)||void 0===_foo$method?void 0:_foo$method.call(foo,!0);\n```\n\nSoureMap:\n```json\n{\n    \"names\":[\"foo\",\"bar\",\"method\"],\n    \"mappings\":\"gBAAA,MAAOA,IAAP,KAAgB,KAAhB,CACA,GAAMC,IAAG,QAAGD,GAAH,WAAGA,GAAH,sBAAGA,GAAG,CAAEE,MAAR,+BAAG,iBAAAF,GAAG,IAAf\"\n}\n```\n\nmappings 解码后的数据为：\n\n每个方括号中内容分别为：转换后的代码第`n`列；转换前的代码中是sources中的第`i`个文件的第`j`行第`k`列；转换前的名称是 names 中的第`x`个\n\n```js\n[\n    // 转换后的第0行\n    [16,0,0,0],\n    [6,0,0,7,0],\n    [4,0,0,-7],\n    [5,0,0,16],\n    [5,0,0,-16],\n    [1,0,1,0],\n    [3,0,0,6,1],\n    [4,0,0,3],\n    [8,0,0,3,-1],\n    [3,0,0,-3],\n    [11,0,0,3,0],\n    [3,0,0,-3],\n    [22,0,0,3,0],\n    [3,0,0,3],\n    [1,0,0,2,2],\n    [6,0,0,-8],\n    [31,0,0,3],\n    [17,0,0,0,-2],\n    [3,0,0,3],\n    [4,0,0,-15]\n]\n```\n\n代码映射关系（局部）可见此图：\n\n![code](./code.png)\n\n# 解析或生成 SourceMap\n\n如笔者存在的对NEJ打包进行改造过程中，对源码分别使用 Babel，UglifyJS 进行了处理，最后做文件合并时，其实是需要将前面输出的 SourceMap 再做一个解析，然后根据文件合并时坐标信息的变换，修改SourceMap并输出新的文件。\n\n[source-map](https://www.npmjs.com/package/source-map) 提供了对 SourceMap 解析、生成的能力，最主要的是将SourceMap中mappings这一难以阅读的VLQ编码进行解码、编码，提供其与转换前后的坐标信息的相互转换。\n\n例如解析mappings：\n\n```js\nconsumer.eachMapping(function (m) { console.log(m); })\n// ...\n// { source: 'illmatic.js',\n//   generatedLine: 1,\n//   generatedColumn: 0,\n//   originalLine: 1,\n//   originalColumn: 0,\n//   name: null }\n// { source: 'illmatic.js',\n//   generatedLine: 2,\n//   generatedColumn: 0,\n//   originalLine: 2,\n//   originalColumn: 0,\n//   name: null }\n// ...\n```"
        },
        {
          "id": "babel-plugin",
          "metadata": {
            "permalink": "/babel-plugin",
            "source": "@site/blog/babel-plugin/index.md",
            "title": "Babel插件指南",
            "description": "本文旨在通过提取官方文档的关键内容，略去一些知识，快速了解插件的基本编写方式，方便你在较低学习成本下写出插件。",
            "date": "2022-09-28T18:00:00.000Z",
            "formattedDate": "2022年9月28日",
            "tags": [
              {
                "label": "babel",
                "permalink": "/tags/babel"
              },
              {
                "label": "ast",
                "permalink": "/tags/ast"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 14.315,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "babel-plugin",
              "title": "Babel插件指南",
              "authors": "auver",
              "date": "2022-09-28T18:00",
              "tags": [
                "babel",
                "ast",
                "javascript"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "SourceMap格式详解",
              "permalink": "/sourcemap"
            },
            "nextItem": {
              "title": "基于RxJs封装友好的跨进程（页面）通信",
              "permalink": "/rxjs-ipc"
            }
          },
          "content": "本文旨在通过提取官方文档的关键内容，略去一些知识，快速了解插件的基本编写方式，方便你在较低学习成本下写出插件。\n\n# 基础\n\nBabel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。\n\n## 抽象语法树（ASTs）\n这个处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。\n\n> Babel 使用一个基于 [ESTree](https://github.com/estree/estree) 并修改过的 AST，它的内核说明文档可以在[这里](https://github. com/babel/babel/blob/master/doc/ast/spec. md)找到。.\n\n```js\nfunction square(n) {\n  return n * n;\n}\n```\n\n这个程序可以被表示成如下的一棵树：\n\n<!-- truncate -->\n\n```\n- FunctionDeclaration:\n  - id:\n    - Identifier:\n      - name: square\n  - params [1]\n    - Identifier\n      - name: n\n  - body:\n    - BlockStatement\n      - body [1]\n        - ReturnStatement\n          - argument\n            - BinaryExpression\n              - operator: *\n              - left\n                - Identifier\n                  - name: n\n              - right\n                - Identifier\n                  - name: n\n```\n\n每一层结构也被叫做 节点（Node）。 一个 AST 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。\n\n我们可以使用 [AST Explorer](https://astexplorer.net/) 来对 AST 节点有一个更好的认识，在后续插件的编写中，也可以通过它来准确遍历节点。\n\n## Babel 的处理步骤\n\nBabel 的三个主要处理步骤分别是： **解析（parse）**，**转换（transform）**，**生成（generate）**。.\n\n### 解析\n\n**解析**步骤接收代码并输出 AST。 这个步骤分为两个阶段：[**词法分析（Lexical Analysis） **](https://en.wikipedia.org/wiki/Lexical_analysis)和 [**语法分析（Syntactic Analysis）**](https://en.wikipedia.org/wiki/Parsing)。\n\n### 转换\n\n这里是插件介入工作的地方。\n[转换](https://en.wikipedia.org/wiki/Program_transformation)步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 \n\n### 生成\n\n[代码生成](https://en.wikipedia.org/wiki/Code_generation_(compiler))步骤把经过一系列转换之后的 AST 转换成字符串形式的代码，同时还会创建[源码映射（source maps）](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/)。.\n\n代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。\n\n# 了解你在插件里要做的事情\n\n以及Babel为了方便你编写插件，已经做的事情。\n\n接下来，我们都会以一个具体的需求为例，方便理解插件要做的事情：\n\n对于同步的循环（`for, for/in, for/of, while, do/while`）执行，期望增加一套检测程序，当循环陷入死循环时，及时抛出异常以终止循环，来避免程序崩溃。判断是否陷入死循环的方式是：增加迭代计数器，当计数到一个足够大的数时，便认为死循环。\n\n如果我们直接在已有的一段代码上增加这段检测代码，应该是这样的，增加前：\n\n```js\nwhile (true) {\n    console.log(1);\n}\n```\n\n增加后：\n\n```js\nlet iterator = 0;\nwhile (true) {\n    if(iterator++>9999999){\n        throw new RangeError(\"Infinite loop: exceeded 9999999 iterations.\");\n    }\n    console.log(1);\n}\n```\n\n试想如果要编写插件，我们要做的事情：\n\n1. 找到所有的循环语句\n2. 在该段循环的父级作用域声明变量，如 `iterator`（变量名的前提是不能和已有的变量冲突），初始值为 0\n3. 对于循环执行语句，如果不是块语句（大括号包裹起来的代码），需要修改为块语句\n4. 在块语句开头，增加一段 if 语句，用于增加变量 `iterator` 的值，并判断`iterator` 是否已经超过设定的阈值（如9999999），如果是则抛出异常\n\n借助Babel，我们希望可以快速达成这些事情：\n\n1. 通过声明告诉 Babel，我们需要在特定的条件下（循环语句这样一个AST节点）处理代码\n2. 对于节点的操作，可能包括节点本身的修改，也可能对节点的父节点进行访问，也可能是需要插入一个子节点。对此，Babel是通过路径 NodePath 来提供相应方法的，来表示节点之间的关联关系。一个 NodePath 对象主要有如下属性\n\n    ```\n    {\n      \"parent\": Node,    // 父节点\n      \"node\": Node,    // 当前的节点\n      \"parentPath\": NodePath,    // 对于父节点，其对应的 path 对象\n      \"container\": [...Node],    // 路径的容器（包含所有同级节点的数组）\n      \"scope\": Scope,    // 作用域对象，后面会讲\n    }\n    ```\n\n    同时 NodePath 对象还包含添加、更新、移动和删除节点有关的其他很多方法，以实现如修改为块语句这样的方法。\n    \n3. 在作用域中声明变量，需要让新增加的变量名字和已有的所有变量不冲突。\n4. 对于新增的这段 if 语句，由 Babel ([babel-template](https://github.com/babel/babel/tree/master/packages/babel-template)) 提供编写字符串形式且带有占位符的代码来代替手动创建 AST。\n\n# 了解 API\n\n## 访问特定的语句\n\n在插件代码中，先写下如下代码，即在模块中导出一个函数，函数返回的对象中，visitor 属性就是这个插件的主要访问者\n\n```js\nexport default function() {\n  return {\n    visitor: {\n      // visitor contents\n    }\n  };\n};\n```\n\n如果要访问 while 循环的代码，我们可以在  [AST Explorer](https://astexplorer.net/) 中，查询其对应的 AST 节点名称，对于源代码：\n\n```js\nwhile (true) {\n    console.log(1);\n}\n```\n其 AST 形式如下：\n\n![ast](./ast.png)\n\n我们便可以添加 `WhileStatement` 访问者方法：\n\n\n```js\nexport default function() {\n  return {\n    visitor: {\n      WhileStatement(path, state) {}\n    }\n  };\n};\n```\n\n`visitor` 中的每个函数接收2个参数：`path` 和 `state`\n\n* `path` 就是当前访问的 `NodePath` 对象\n* `state` 是插件启动时传入的一些参数\n```js\n{\n    cwd: '',    // process.cwd()\n    file: File,\n    filename: ’‘, // 当前处理的文件名称\n    opts: {} // 接受用户可以指定的插件特定选项\n}\n```\n\nopts 是用户引入当前插件时，传入的选项\n\n\n```js\n{\n  plugins: [\n    [\"my-plugin\", {\n      \"option1\": true,\n      \"option2\": false\n    }]\n  ]\n}\n```\n\n如有必要，你还可以把方法名用 `|` 分割成 `Idenfifier |MemberExpression` 形式的字符串，把同一个函数应用到多种访问节点。.\n\n也可以在访问者中使用别名（如[babel-types](https://github.com/babel/babel/tree/master/packages/babel-types/src/definitions)定义），如使用 `Loop` 表示所有循环语句：\n\n```js\nreturn {\n    visitor: {\n        'Loop': () => {}\n    }\n}\n```\n\n\n## 验证与创建节点\n\n* 通过 `@babel/core` 导入 `types` 对象\n\n```js\nimport { types as t } from '@babel/core';\ntypes.isIdentifier(path.node)\n```\n\n* 通过 `babel-types` 导入\n\n```js\nimport * as t from \"babel-types\";\ntypes.isIdentifier(path.node)\n```\n\n* 插件导出函数的入参也有 `types` 对象\n\n该模块是一个用于 AST 节点的 Lodash 式工具库， 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理AST逻辑非常有用。\n\n完整的方法可参考 [babel-types API](https://babeljs.io/docs/en/babel-types)\n\n### 验证节点\n\n* 通过 `t.isX` 方法\n\n```js\nt.isBinaryExpression(maybeBinaryExpressionNode);\n```\n这个测试用来确保节点是一个二进制表达式，另外你也可以传入第二个参数来确保节点包含特定的属性和值。\n\n```js\nt.isBinaryExpression(maybeBinaryExpressionNode, { operator: \"*\" });\n```\n\n* 通过 `t.assert` 方法\n\n这类方法会抛出异常而不是返回 true 或 false\n\n```js\nt.assertBinaryExpression(maybeBinaryExpressionNode, { operator: \"*\" });\n```\n\n* 在 NodePath 上同样可以访问到 `isX` 方法\n\n```js\nIdentifier(path) {\n  if (path.isIdentifier({ name: \"n\" })) {\n    // ...\n  }\n}\n```\n\n相当于\n\n```js\nIdentifier(path) {\n  if (t.isIdentifier(path.node, { name: \"n\" })) {\n    // ...\n  }\n}\n```\n\n### 创建节点\n\n按类似下面的方式使用：\n\n```js\nt.binaryExpression(\"*\", t.identifier(\"a\"), t.identifier(\"b\"));\n```\n\n可以创建如下所示的 AST：\n\n```js\n{\n  type: \"BinaryExpression\",\n  operator: \"*\",\n  left: {\n    type: \"Identifier\",\n    name: \"a\"\n  },\n  right: {\n    type: \"Identifier\",\n    name: \"b\"\n  }\n}\n```\n\n当打印出来之后是这样的：\n\n```\na * b\n```\n\n###  创建一个无冲突的变量名\n\n需要访问 `scope` 来生成一个标识符，不会与任何本地定义的变量相冲突\n\n```js\nconst node = path.scope.generateUidIdentifier(\"xxx\");\n```\n\n其返回的是一个 `Identifier` 类型的 `Node`，然后可以将该变量名和初始化值，传给 scope，以在当前作用域创建变量的声明与初始化。\n\n```js\npath.scope.push({ id: node, init: t.numericLiteral(0) });\n```\n\n### 通过编写字符串生成节点\n\n[@babel/template](https://github.com/babel/babel/tree/master/packages/babel-template) 能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST的时候。\n\n在字符串中，你可以使用 语法占位符（例如%%name%%）或标识符占位符（例如NAME）（但不能混合使用）\n\n随后，通过传入参数的方式来填充这些占位符。\n\n```js\nimport { template, types as t } from '@babel/core';\n\nconst buildRequire = template(`\n  var IMPORT_NAME = require(SOURCE);\n`);\n\nconst ast = buildRequire({\n  IMPORT_NAME: t.identifier(\"myModule\"),\n  SOURCE: t.stringLiteral(\"my-module\")\n});\n\n```\n\n如果不需要占位符，可以直接将字符串解析为 AST：\n\n```js\nconst ast = template.ast(`\n  var myModule = require(\"my-module\");\n`);\n```\n\n具体使用方式可查看[babel/template API](https://babeljs.io/docs/en/babel-template)\n\n## 通过 NodePath 访问其他节点或path\n\n### 获取父节点\n\n```\npath.parent\n```\n\n### 获取父节点的path\n\n```\npath.parentPath\n```\n\n### 获取子节点\n\n需要根据具体的 AST 节点类型进行处理。例如，对于 `WhileStatement`，其 AST节点格式如下：\n\n```json\n{\n      \"type\": \"WhileStatement\",\n      \"test\": {\n        \"type\": \"Literal\",\n        \"value\": true,\n        \"raw\": \"true\"\n      },\n      \"body\": {\n        \"type\": \"BlockStatement\",\n        \"start\": 13,\n        \"end\": 36,\n        \"body\": []\n      }\n    }\n```\n\n利用 `path.node[property]` 方法即可获取子节点，例如通过 `path.node.test` 访问到循环的条件表达式这一个节点，通过 `path.node.body` 访问到循环的执行语句。\n\n### 获取子节点的Path\n\n使用`path`对象的`get`方法，传递该属性的字符串形式作为参数。同上，例如通过 `path.get('test')` 访问到循环的条件表达式这一个节点，通过 `path.get('body.0')` 甚至可以进行多层的访问。\n\n### 找到特定的祖先路径\n\n有时你需要从一个路径向上遍历语法树，直到满足相应的条件。\n\n对于每一个父路径调用`callback`并将其`NodePath`当作参数，当`callback`返回真值时，则将其`NodePath`返回。.\n\n```\npath.findParent((path) => path.isObjectExpression());\n```\n\n如果也需要遍历当前节点：\n\n```\npath.find((path) => path.isObjectExpression());\n```\n\n查找最接近的父函数或程序：\n\n```\npath.getFunctionParent();\n```\n\n向上遍历语法树，直到找到在列表中的父节点路径\n\n```\npath.getStatementParent();\n```\n\n### 获取同级路径\n\n如果一个路径是在一个 `Function`／`Program` 中的列表里面，它就有同级节点。\n\n使用 `path.container` 获取路径的容器（包含所有同级节点的数组）\n\n## 通过 NodePath 修改节点\n\n可以通过 [d.ts 文件](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/babel-traverse/index.d.ts#L327) 了解所有的方法\n\n### 替换一个节点\n\n```js\npath.replaceWith(\n    t.binaryExpression(\"**\", path.node.left, t.numberLiteral(2))\n);\n```\n\n### 用多节点替换单节点\n\n```js\npath.replaceWithMultiple([...Nodes])\n```\n\n### 插入兄弟节点\n\n```js\npath.insertBefore(Node);\npath.insertAfter(Node);\n```\n### 插入到容器（container）中\n\n指的是对于函数语句，插入到其 `body` 的开头或结尾。\n\n```js\npath.get('body').unshiftContainer(Node);\npath.get('body').pushContainer(Node);\n```\n\n# 编写代码\n\n## 找到所有的循环语句\n\n```js\nexport default () => {\n    return {\n        visitor: {\n            'Loop': (\n                path\n            ) => {\n            }\n        }\n    }\n}\n```\n\n## 声明变量iterator\n\n\n```js\nexport default () => {\n    return {\n        visitor: {\n            'Loop': (\n                path\n            ) => {\n                // An iterator that is incremented with each iteration\n                const iterator = path.scope.parent.generateUidIdentifier('i');\n                const iteratorInit = t.numericLiteral(0);\n                path.scope.parent.push({\n                    id: iterator,\n                    init: iteratorInit,\n                });\n            }\n        }\n    }\n}\n```\n\n相当于\n\n```js\nlet iterator = 0;\nwhile (true) {\n    console.log(1);\n}\n```\n\n## 增加iterator的判断语句\n\n我们通过 `template` 实现。因为需要传入 iterator 这个变量名，需要使用占位符。\n\n```js\nconst buildGuard = template(`\nif (ITERATOR++ > MAX_ITERATIONS) {\n    throw new RangeError(\n        'Infinite loop: exceeded ' +\n        MAX_ITERATIONS +\n        ' iterations.'\n    );\n}`);\n\nconst guard = buildGuard({\n    ITERATOR: iterator,\n    MAX_ITERATIONS: t.numericLiteral(MAX_ITERATIONS)\n});\n```\n\n随后是插入这段判断语句\n\n```js\nconst { node } = path;\nconst { body } = node;\nif (!t.isBlockStatement(body)) {\n    path.get('body').replaceWith(t.blockStatement([guard, body]));\n} else {\n    path.get('body').unshiftContainer('body', guard);\n}\n```"
        },
        {
          "id": "rxjs-ipc",
          "metadata": {
            "permalink": "/rxjs-ipc",
            "source": "@site/blog/rxjs-ipc/index.md",
            "title": "基于RxJs封装友好的跨进程（页面）通信",
            "description": "本文将以热门的跨平台桌面应用构建方案 Electron 为例，讲讲在跨进程通信中出现的痛点，并使用RxJs解决这些问题，当然这里的方案不仅仅适用于Electron，同样可以复制到如跨页面通信，主页面与 worker 之间的场景。",
            "date": "2022-06-23T10:00:00.000Z",
            "formattedDate": "2022年6月23日",
            "tags": [
              {
                "label": "rxjs",
                "permalink": "/tags/rxjs"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 6.935,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "rxjs-ipc",
              "title": "基于RxJs封装友好的跨进程（页面）通信",
              "authors": "auver",
              "date": "2022-06-23T10:00",
              "tags": [
                "rxjs",
                "javascript"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "Babel插件指南",
              "permalink": "/babel-plugin"
            },
            "nextItem": {
              "title": "从0到1，实现Electron应用自动更新功能",
              "permalink": "/electron-apps-automatically-update"
            }
          },
          "content": "本文将以热门的跨平台桌面应用构建方案 Electron 为例，讲讲在跨进程通信中出现的痛点，并使用RxJs解决这些问题，当然这里的方案不仅仅适用于Electron，同样可以复制到如跨页面通信，主页面与 worker 之间的场景。\n\n# 现状\n\nElectron 主进程和渲染进程间，官方提供了[基础的通信能力](https://www.electronjs.org/docs/latest/tutorial/ipc)。例如，在主进程中向渲染进程发布消息的方式为：\n\n```js\nwebContents.send('ping', 'whoooooooh!')\n```\n\n渲染进程响应方式为：\n\n```js\n.ipcRenderer.on('ping', (event, message) => {\n    console.log(message) // Prints 'whoooooooh!'\n})\n```\n\n支持在响应函数中同步（`event.returnValue`）或者异步（`event.reply`）的回复消息。对于`event.reply`来说，其本质是发送一条新的不同类型的消息，该消息指定了接收方。\n\n在实际使用场景里，往往是甲方产生消费需求，发送消息告知乙方其需要消费数据，由乙方生产数据后回复消息供消费者消费。为了方便描述，我们把首先发送消息的甲方称为消费者，回复消息的乙方称为生产者。\n\n<!-- truncate -->\n\n对于生产者消费者1对1且只消费一次来说，这种消息模式是没有什么问题的。但放到实际的开发场景中，会发现有一些非1对1单次消费的场景，并由此产生问题：\n\n* 在某个渲染进程中，有多个场景，因此有多个消费者，均通过向主进程（一个生产者）发送相同类型的消息请求消费，等待生产者回复消息，消息类型为 `reply`，这多个消费者需要分别对 `reply` 注册事件响应程序。当生产者回复消息时，这些消费者默认是无法分辨出这个 reply` 事件到底是不是回复给自己的。即生产者生产多个数据以后，无法分辨该数据需要给哪个消费者消费。\n\n    又因为 Electron 的消息是通过结构化克隆发送的，通过传入回调函数来作为回复也是不可行的。\n    \n* 生产者未做好准备时，消费者便已发出消息，消息未能成功到达生产者，消息丢失，无法消费数据。\n    \n* 需要消费多次，即生产者需要异步地回复多条消息。\n\n    对于仅做一次的回复消息，Promise 就可以满足。但是如果需要做多次的消息回复，Observable 是更简单有效的办法。\n\n# Observable 的优点\n\n* 如上所述，Observable 可以满足消费多次的场景\n\n* 消除了同步和异步事件在响应时的差异。\n\n* Observable 默认是冷执行的。即无消费者的情况下，生产者不会进行生产。当所有消费者消费完毕，生产者也可以马上停下。\n\n# 设计\n\n可以说，因为 Observable 的设计，这个模块其实是做了这样的事情：\n\n在进程 A 创建生产者。在进程 B 创建消费者。当消费者执行订阅时，通过通信能力，实际向进程 A 的生产者发起了订阅。\n\n而发起订阅和订阅数据的接受过程中的通信机制被模块隐藏了起来。使用者可以当做普通的 Observable 去订阅。\n\n![image](https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/10646909591/b939/b24e/1941/800c5f41f22d5ee18a8082ec8efc5801.png)\n\n## 生产者\n```js\n// 由该函数创建一个 Observable 供订阅。如果你返回的是 Promise 或者其他值，会被包装成 Observable\n// 函数第0个参数是 IpcEvent，后面才是消费者传入的参数\nfunction createObservable(event, ...args) {\n    return Observable.from(args);\n}\n\nrxIpc.createProvider('eventName', createObservable);\n```\n\n## 消费者\n```js\n// 可以传入多个参数\nrxIpc.createConsumer('eventName', ...args).subscribe(() => {\n    //\n});\n```\n\n生产者与消费者的创建顺序没有要求。一旦双方均完成创建，生产者可以根据消费者需求开始生产数据。因为在生产者创建的过程中，会发送消息通知消费者，此时如果消费者已经创建，将会先收到生产者的通知。反之，消费者创建时，检测到生产者已经创建，将马上开始消费请求。\n\n当消费者取消订阅，生产者也会停止生产。考虑到像 Electron 中，可能出现页面关闭，渲染进程关闭，消费者未来得及取消订阅的情况，额外监听了 \"destroyed\" 事件，在 destroyed 后马上停止生产。\n\n# 进阶\n\n## 开发新场景\n\n不仅仅局限于Electron，这种通信方式可以复制到如跨页面通信，主页面与 worker 之间的场景。可以根据需要，适配不同的通信方式，如 LocalStorage。\n\n## 面向对象\n\n可以借助已有的 Class 创建生产者和消费者。\n\n对于创建消费者 Class 的方法，返回一个新的 Class，其实是将各个方法进行了代理，发送消息到创建者，然后收到响应。\n\n在使用时，需要注意的是：\n\n* 构造函数不支持异步。但显然在跨进程通信机制下，对象的创建是异步的。\n\n* 不用担心，消费者对象中任意方法的调用，会等待对象创建完成后继续。同 createConsumer 类似，这些方法会返回 Observable，只需对其订阅即可。\n\n* 创建对象因其特殊性，没法返回 Observable 进行订阅。但可以在创建消费者对象时传入 ComsumeEvent 获得在生产者一侧实际创建成功或者失败的回调。"
        },
        {
          "id": "electron-apps-automatically-update",
          "metadata": {
            "permalink": "/electron-apps-automatically-update",
            "source": "@site/blog/electron-apps-automatically-update/index.md",
            "title": "从0到1，实现Electron应用自动更新功能",
            "description": "Electron的自动更新能力完全由Squirrel提供。我们先来了解下Squirrel能够提供怎样的更新能力：",
            "date": "2022-04-11T18:00:00.000Z",
            "formattedDate": "2022年4月11日",
            "tags": [
              {
                "label": "electron",
                "permalink": "/tags/electron"
              }
            ],
            "readingTime": 8.2,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "electron-apps-automatically-update",
              "title": "从0到1，实现Electron应用自动更新功能",
              "authors": "auver",
              "date": "2022-04-11T18:00",
              "tags": [
                "electron"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "基于RxJs封装友好的跨进程（页面）通信",
              "permalink": "/rxjs-ipc"
            },
            "nextItem": {
              "title": "React Hooks 最佳实践",
              "permalink": "/react-hooks-best-practices"
            }
          },
          "content": "Electron的自动更新能力完全由Squirrel提供。我们先来了解下Squirrel能够提供怎样的更新能力：\n\n## 在 Windows 上\nSquirrel提供了应用程序从打包到安装、更新各阶段的能力。换一句话说，如果需要使用自动更新能力，那么应用程序的打包、安装也需要Squirrel的参与。\n\n通过Squirrel打包的应用程序，在安装阶段，无需用户选择安装目录，也没有UAC对话框，应用将自动安装到`%USERPROFILE%\\AppData\\Local`目录下。\n\n在更新阶段，无需用户做任何操作，Squirrel将在后台静默下载，待用户下次打开应用时就会替换为新的包。\n\n出于后续自动更新的需要，应用的包文件，存放在以版本号命名的目录下。当有更新可用时，Squirrel下载新的包文件，采用同样的命名规则，存放在新目录下。应用的安装目录是这样的：\n\n![folder](./folder.png)\n\n该目录下的`Stetho.exe`相当于启动引导，当运行该可执行文件时，将选择最新版本的包中的文件执行。\n\n也正因为此，这个`%USERPROFILE%\\AppData\\Local\\Stetho.exe`始终作为用户执行的入口，在第一次安装阶段，就建议以该可执行文件创建快捷方式（创建方法在下文有提到）。\n\n<!-- truncate -->\n\n## 在 MacOS 上\n\n我们知道，在MacOS上，常规的应用程序（非AppStore）安装方式是打开`.dmg`文件，将应用直接拖入应用目录中。应用图标也能够自动在启动台等处出现。Squirrel打包的应用程序，在安装阶段不会有差异。在更新时，Squirrel将静默下载新包，在应用程序关闭后将执行自动安装。你也可用在更新下载完成后，提示用户有更新，确认后便会重启应用顺便更新一下。具体表现，同网易云音乐Mac端（[可以通过在官网下载体验](https://music.163.com/#/download)）类似。\n\n# 在Electron应用中集成Squirrel\n根据Electron的[文档](https://www.electronjs.org/zh/docs/latest/api/auto-updater/)，在 MacOS 上，无需做如何操作，已经内置Squirrel.Mac；在Windows中，就像前面说的，依赖于你的安装程序也要有Squirrel的参与，才能将Squirrel集成进来。而这个安装程序的生成，需要由你自己配置。像[electron-winstaller](https://github.com/electron/windows-installer), [electron-forge](https://github.com/electron-userland/electron-forge) 或者 [grunt-electron-installer](https://github.com/electron/grunt-electron-installer) 均可。\n\n笔者使用的是 electron-forge，就支持[集成Squirrel到安装程序](https://www.electronforge.io/config/makers/squirrel.windows)中，更是支持将[一些配置](https://js.electronforge.io/maker/squirrel/interfaces/makersquirrelconfig)透传到Squirrel，以实现一些安装程序的定制，例如安装程序可执行文件（非应用启动时使用的可执行文件）的图标、文件名，甚至是loading动画。\n\n# 在Electron应用中处理更新逻辑\n\n借助Electron主进程中提供的[autoUpdater模块](https://www.electronjs.org/zh/docs/latest/api/auto-updater/)，我们不需要直接与Squirrel对接，抹平了Squirrel双端的差异，也不需要去看[Squirrel复杂的文档](https://github.com/Squirrel/Squirrel.Windows/tree/master/docs)。\n\n在Electron主进程下，可以待app启动后，执行更新的检查（`autoUpdater.checkForUpdates()`）。在此之前，必须先设置检查更新的服务器地址（`autoUpdater.setFeedURL(options)`），对于服务器的搭建，下个章节将做介绍。\n\n开发者可以自行设定条件（例如设定每1小时一次），重复进行检查更新。\n当有可用更新，且Squirrel已完成更新的下载，将触发`'update-downloaded'`事件，此时可用提醒用户更新可用，马上执行安装，亦或是不做任何提醒，当用户下次打开应用后，更新也会生效。\n\n在autoUpdater的文档中，已经介绍得比较清楚了，此处不再详述。读者亦可参考[Electron官方的示例文件](https://github.com/electron/update-electron-app/blob/master/index.js)。\n\n# 搭建更新服务器\n\n在[示例文件](https://github.com/electron/update-electron-app/blob/master/index.js)中，可以看到`feedURL` 的设置方式：\n\n```js\nconst feedURL = `${host}/${repo}/${process.platform}-${process.arch}/${app.getVersion()}`\n```\n\n笔者推荐也是采用这种方式，将`platform`, `version`等通过path方式传递。原因很简单，Squirrel封装的更新请求方式如下：\n\n```\nGET ${feedURL}/?id=${appId}&localVersion=${version}&arch=${arch}\n```\n\nQuery 中并没有 `platform`。\n\n对于直接托管在GitHub的项目，可以直接使用 https://update.electronjs.org/ 服务搭建更新服务器。对于需要进行私有部署的，就要参考[这个服务的代码](https://github.com/electron/update.electronjs.org/blob/2f8bac21d9036a557824d34823fdd66fbb261da3/index.js)了。\n\n直接访问update.electronjs.org示例应用的 API，可以发现API的格式。\nhttps://update.electronjs.org/electron/electron-api-demos/win32/1.0.0\n```json\n{\n  \"name\": \"2.0.2\",\n  \"notes\": \"Updated to Electron 4.0.1\",\n  \"url\": \"https://github.com/electron/electron-api-demos/releases/download/v2.0.2/ElectronAPIDemosSetup.exe\"\n}\n```\nhttps://update.electronjs.org/electron/electron-api-demos/win32/1.0.0/RELEASES\n```\n612ABC1A6317213550284A508C98AB679690BA7C https://github.com/electron/electron-api-demos/releases/download/v2.0.2/electron-api-demos-2.0.2-full.nupkg 61704801\n```\n\n只需要按照这些格式实现 API 即可。\n\n对于细节的处理，建议参考update.electronjs.org的实现，可能有诸如同`platform`，不同`arch`处理之类的逻辑。\n\n## MacOS端\n\n需要实现 `${feedURL}` 该API接口，响应JSON，包含以下几个属性：\n```\npub_date: Date,\nnotes: string,\nname: string,\nurl: string // 安装文件的地址\n```\n\n这些属性，将在 Electron 的 'update-downloaded' 事件中返回，供处理诸如弹窗的逻辑。也就是说，如果在你的应用中不需要，除了url，其他内容可以不返回。\n\n## Windows 端\n\n需要实现的是 `${feedURL}/RELEASES`，该接口返回 `RELEASES` 文件。该文件可以在打包的输出目录中找到（和安装程序exe，nupkg文件一起）\n\n![output](./output.png)\n\n文件中引用了 `.nupkg` 文件的地址。该文件就是自动更新时下载的包文件。打包时该地址是相对路径，需要自行替换为完整的 CDN 地址。\n\n```js\nconst res = await ctx.curl(releaseLink, {\n    dataType: 'text',\n});\ntext = res.data.replace(/[^ ]*\\.nupkg/gim, nupkgLink);\n```\n\n## 全新下载\n\n对于新用户，提供下载链接。此时 Windows 端提供`安装程序exe`文件，而不是`nupkg文件`。\n\n# 在Squirrel.Windows安装阶段处理额外逻辑（创建快捷方式等）\n\n在 Squirrel.Windows 的安装、卸载等不同阶段，将向你的应用程序传入不同的启动参数（[事件列表](https://github.com/Squirrel/Squirrel.Windows/blob/master/src/Update/Program.cs#L98)）。\n\n你可以这么处理他们：\n\n```js\nvar handleStartupEvent = function() {\n  if (process.platform !== 'win32') {\n    return false;\n  }\n\n  var squirrelCommand = process.argv[1];\n  switch (squirrelCommand) {\n    case '--squirrel-install':\n    case '--squirrel-updated':\n\n      // Optionally do things such as:\n      //\n      // - Install desktop and start menu shortcuts\n      // - Add your .exe to the PATH\n      // - Write to the registry for things like file associations and\n      //   explorer context menus\n\n      // Always quit when done\n      app.quit();\n\n      return true;\n    case '--squirrel-uninstall':\n      // Undo anything you did in the --squirrel-install and\n      // --squirrel-updated handlers\n\n      // Always quit when done\n      app.quit();\n\n      return true;\n    case '--squirrel-obsolete':\n      // This is called on the outgoing version of your app before\n      // we update to the new version - it's the opposite of\n      // --squirrel-updated\n      app.quit();\n      return true;\n  }\n};\n\n```\n\n像 [electron-squirrel-startup](https://www.npmjs.com/package/electron-squirrel-startup) 这样的包，实现了在这些不同阶段，对应用的快捷方式进行了管理。\n\n当然，你也可以自己处理这些事件，可以实现诸如注册默认应用程序、注册 web Message等的管理，此处不再做介绍。"
        },
        {
          "id": "react-hooks-best-practices",
          "metadata": {
            "permalink": "/react-hooks-best-practices",
            "source": "@site/blog/react-hooks-best-practices/index.md",
            "title": "React Hooks 最佳实践",
            "description": "写在前面",
            "date": "2020-03-18T10:00:00.000Z",
            "formattedDate": "2020年3月18日",
            "tags": [
              {
                "label": "hooks",
                "permalink": "/tags/hooks"
              },
              {
                "label": "react",
                "permalink": "/tags/react"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 37.1,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "react-hooks-best-practices",
              "title": "React Hooks 最佳实践",
              "authors": "auver",
              "date": "2020-03-18T10:00",
              "tags": [
                "hooks",
                "react",
                "javascript"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "从0到1，实现Electron应用自动更新功能",
              "permalink": "/electron-apps-automatically-update"
            },
            "nextItem": {
              "title": "云音乐桌面端基于 RxJs 的数据层探索",
              "permalink": "/rxjs-on-the-netease-cloud-music-desktop"
            }
          },
          "content": "## 写在前面\n\n在过去的几个月里，React Hooks 在我们的项目中得到了充分利用。在实际使用过程中，我发现 React Hooks 除了带来简洁的代码外，也存在对其使用不当的情况。\n\n在这篇文章中，我想总结我过去几个月来对 React Hooks 使用，分享我对它的看法以及我认为的最佳实践，供大家参考。\n\n本文假定读者已经对 React-Hooks 及其使用方式有了初步的了解。您可以通过 [官方文档](https://reactjs.org/docs/hooks-intro.html) 进行学习。\n\n## 函数式组件\n\n简而言之，就是在一个函数中返回 React Element。\n\n```jsx\nconst App = (props) => {\n    const { title } = props;\n    return (\n        <h1>{title}</h1>\n    );  \n};\n\n```\n\n一般的，该函数接收唯一的参数：props 对象。从该对象中，我们可以读取到数据，并通过计算产生新的数据，最后返回 React Elements 以交给 React 进行渲染。此外也可以选择在函数中执行副作用。\n\n在本文中，我们给函数式组件的函数起个简单一点的名字：render 函数。\n\n<!-- truncate -->\n\n```js\nconst appElement = App({ title: \"XXX\" });\nReactDOM.render(\n    appElement,\n    document.getElementById('app')\n);\n```\n\n在上方的代码中，我们自行调用了 render 函数以期执行渲染。然而这在 React 中不是正常的操作。\n\n正常操作是像下方这样的代码：\n\n```jsx\n// React.createElement(App, {\n//     title: \"XXX\"\n// });\nconst appElement = <App title=\"XXX\" />;\nReactDOM.render(\n    appElement,\n    document.getElementById('app')\n);\n```\n\n在 React 内部，它会决定在何时调用 render 函数，并对返回的 React Elements 进行遍历，如果遇到函数组件，React 便会继续调用这个函数组件。在这个过程中，可以由父组件通过 props 将数据传递到该子组件中。最终 React 会调用完所有的组件，从而知晓如何进行渲染。\n\n这种把 render 函数交给 React 内部处理的机制，为引入状态带来了可能。\n\n在本文中，为了方便描述，对于 render 函数的每次调用，我想称它为一帧。\n\n## 每一帧拥有独立的变量\n\n在引入状态之前，我们需要明白这一点。\n\n我们通过 *例一* 进行观察：\n\n[![Edit 1. 每一帧拥有独立的变量](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/serverless-microservice-35z1y?fontsize=14&hidenavigation=1&module=%2Fsrc%2FExample.js&theme=dark)\n\n```jsx\nfunction Example(props) {\n    const { count } = props;\n    const handleClick = () => {\n        setTimeout(() => {\n            alert(count);\n        }, 3000);\n    };\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={handleClick}>Alert Count</button>\n        </div>\n    );\n}\n```\n\n重点关注 `<Example>` 函数组件的代码，其中的 `count` 属性由父组件传入，初始值为 0，每隔一秒增加 1。点击 \"Alert Count\" 按钮，将延迟 3 秒钟弹出 `count` 的值。操作后发现，弹窗中出现的值，与页面中文本展示的值不同，而是等于点击 \"alert Count\" 按钮时 `count` 的值。\n\n如果更换为 class 组件，它的实现是 `<Example2>` 这样的：\n\n```jsx\nclass Example2 extends Component {\n    handleClick = () => {\n        setTimeout(() => {\n            alert(this.props.count);\n        }, 3000);\n    };\n\n    render() {\n        return (\n            <div>\n                <h2>Example2</h2>\n                <p>{this.props.count}</p>\n                <button onClick={this.handleClick}>Alert Count</button>\n            </div>\n        );\n    }\n}\n```\n\n此时，点击 \"Alert Count\" 按钮，延迟 3 秒钟弹出 `count` 的值，与页面中文本展示的值是一样的。\n\n在某些情况下，`<Example>` 函数组件中的行为才符合预期。如果将 `setTimeout` 类比到一次 Fetch 请求，在请求成功时，我要获取的是发起 Fetch 请求前相关的数据，并对其进行修改。\n\n如何理解其中的差异呢？\n\n在 `<Example2>` class 组件中，我们是从 `this` 中获取到的 `props.count`。`this` 是固定指向同一个组件实例的。在 3 秒的延时器生效后，组件重新进行了渲染，`this.props` 也发生了改变。当延时的回调函数执行时，读取到的 `this.props` 是当前组件最新的属性值。\n\n而在 `<Example>` 函数组件中，每一次执行 render 函数时，`props` 作为该函数的参数传入，它是函数作用域下的变量。\n\n当 `<Example>` 组件被创建，将运行类似这样的代码来完成第一帧：\n\n```jsx\nconst props_0 = { count: 0 };\n\nconst handleClick_0 = () => {\n    setTimeout(() => {\n        alert(props_0.count);\n    }, 3000);\n};\nreturn (\n    <div>\n        <h2>Example</h2>\n        <p>{props_0.count}</p>\n        <button onClick={handleClick_0}>alert Count</button>\n    </div>\n);\n```\n\n当父组件传入的 count 变为 1，React 会再次调用 `Example` 函数，执行第二帧，此时 `count` 是 `1`。\n\n```jsx\nconst props_1 = { count: 1 };\n\nconst handleClick_1 = () => {\n    setTimeout(() => {\n        alert(props_1.count);\n    }, 3000);\n};\nreturn (\n    <div>\n        <h2>Example</h2>\n        <p>{props_1.count}</p>\n        <button onClick={handleClick_1}>alert Count</button>\n    </div>\n);\n```\n\n由于 `props` 是 `Example` 函数作用域下的变量，可以说对于这个函数的每一次调用中，都产生了新的 `props` 变量，它在声明时被赋予了当前的属性，他们相互间互不影响。\n\n换一种说法，对于其中任一个 `props` ，其值在声明时便已经决定，不会随着时间产生变化。`handleClick` 函数亦是如此。例如定时器的回调函数是在未来发生的，但 `props.count` 的值是在声明 `handleClick` 函数时就已经决定好的。\n\n如果我们在函数开头使用解构赋值，`const { count } = props`，之后直接使用 `count`，和上面的情况没有区别。\n\n## 状态\n\n可以简单的认为，在某个组件中，对于返回的 React Elements 树形结构，某个位置的 element ，其类型与 key 属性均不变，React 便会选择重用该组件实例；否则，比如从 `<A/>` 组件切换到了 `<B/>` 组件，会销毁 A，然后重建 B，B 此时会执行第一帧。\n\n在实例中，可以通过 `useState` 等方式拥有局部状态。在重用的过程中，这些状态会得到保留。而如果无法重用，状态会被销毁。\n\n例如 `useState`，为当前的函数组件创建了一个状态，这个状态的值独立于函数存放。 `useState` 会返回一个数组，在该数组中，得到该状态的值和更新该状态的方法。通过解构，该状态的值会赋值到当前 render 函数作用域下的一个常量 `state` 中。\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n当组件被创建而不是重用时，即在组件的第一帧中，该状态将被赋予初始值 `initialState`，而之后的重用过程中，不会被重复赋予初始值。\n\n通过调用 `setState` ，可以更新状态的值。\n\n## 每一帧拥有独立的状态\n\n需要明确的是，`state` 作为函数中的一个常量，就是普通的数据，并不存在诸如数据绑定这样的操作来驱使 DOM 发生更新。在调用 `setState` 后，React 将重新执行 render 函数，仅此而已。\n\n因此，状态也是函数作用域下的普通变量。我们可以说每次函数执行拥有独立的状态。\n\n为了加深印象，我们来看 *例二*，它是 React 官网某个例子的复杂化：\n\n[![Edit 每一帧拥有独立的状态](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/hardcore-fast-66u24?fontsize=14&hidenavigation=1&theme=dark)\n\n```jsx\nfunction Example2() {\n    const [count, setCount] = useState(0);\n\n    const handleClick = () => {\n        setTimeout(() => {\n            setCount(count + 1);\n        }, 3000);\n    };\n\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={() => setCount(count + 1)}>\n                setCount\n            </button>\n            <button onClick={handleClick}>\n                Delay setCount\n            </button>\n        </div>\n    );\n}\n```\n\n在第一帧中，`p` 标签中的文本为 0。点击 \"Delay setCount\"，文本依然为 0。随后在 3 秒内连续点击 \"setCount\" 两次，将会分别执行第二帧和第三帧。你将看到 `p` 标签中的文本由 0 变化为 1, 2。但在点击 \"Delay setCount\" 3 秒后，文本重新变为 1。\n\n```jsx\n// 第一帧\nconst count_1 = 0;\n\nconst handleClick_1 = () => {\n    const delayAction_1 = () => {\n        setCount(count_1 + 1);\n    };\n    setTimeout(delayAction_1, 3000);\n};\n\n//...\n<button onClick={handleClick_1}>\n//...\n\n// 点击 \"setCount\" 后第二帧\nconst count_2 = 1;\n\nconst handleClick_2 = () => {\n    const delayAction_2 = () => {\n        setCount(count_2 + 1);\n    };\n    setTimeout(delayAction_2, 3000);\n};\n\n//...\n<button onClick={handleClick_2}>\n//...\n\n// 再次点击 \"setCount\" 后第三帧\nconst count_3 = 2;\n\nconst handleClick_3 = () => {\n    const delayAction_3 = () => {\n        setCount(count_3 + 1);\n    };\n    setTimeout(delayAction_3, 3000);\n};\n\n//...\n<button onClick={handleClick_3}>\n//...\n```\n\n`count`，`handleClick` 都是 `Example2` 函数作用域中的常量。在点击 \"Delay setCount\" 时，定时器设置 3000ms 到期后的执行函数为 `delayAction_1`，函数中读取 `count_1` 常量的值是 0，这和第二帧的 `count_2` 无关。\n\n## 获取过去或未来帧中的值\n\n对于 state，如果想要在第一帧时点击 \"Delay setCount\" ，在一个异步回调函数的执行中，获取到 `count` 最新一帧中的值，不妨向 `setCount` [传入函数作为参数](https://reactjs.org/docs/hooks-reference.html#functional-updates)。\n\n其他情况下，例如需要读取到 state 及其衍生的某个常量，相对于变量声明时所在帧过去或未来的值，就需要使用 `useRef`，通过它来拥有一个在所有帧中共享的变量。\n\n如果要与 class 组件进行比较，`useRef` 的作用相对于让你在 class 组件的 `this` 上追加属性。\n\n```js\nconst refContainer = useRef(initialValue);\n```\n\n在组件的第一帧中，`refContainer.current` 将被赋予初始值 `initialValue`，之后便不再发生变化。但你可以自己去设置它的值。设置它的值不会重新触发 render 函数。\n\n例如，我们把第 n 帧的某个 props 或者 state 通过 `useRef` 进行保存，在第 n + 1 帧可以读取到过去的，第 n 帧中的值。我们也可以在第 n + 1 帧使用 ref 保存某个 props 或者 state，然后在第 n 帧中声明的异步回调函数中读取到它。\n\n对 *例二* 进行修改，得到 *例三*，看看具体的效果：\n\n[![Edit 获取过去或未来帧中的值\n](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/recursing-dan-b1syo?fontsize=14&hidenavigation=1&theme=dark)\n\n```jsx\nfunction Example() {\n    const [count, setCount] = useState(0);\n\n    const currentCount = useRef(count);\n\n    currentCount.current = count;\n\n    const handleClick = () => {\n        setTimeout(() => {\n            setCount(currentCount.current + 1);\n        }, 3000);\n    };\n\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={() => setCount(count + 1)}>\n                setCount\n            </button>\n            <button onClick={handleClick}>\n                Delay setCount\n            </button>\n        </div>\n    );\n}\n```\n\n在 `setCount` 后便会执行下一帧，在函数的开头，\n`currentCount` 始终与最新的 `count` state 保持同步。因此，在 `setTimeout` 中可以通过此方法获取到回调函数执行时当前的 count 值。\n\n接下来再通过 *例四* 了解如何获取过去帧中的值：\n\n[![Edit 获取过去帧中的值](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/snowy-voice-e4lyn?fontsize=14&hidenavigation=1&theme=dark)\n\n```jsx\nfunction Example4() {\n    const [count, setCount] = useState(1);\n\n    const prevCountRef = useRef(1);\n    const prevCount = prevCountRef.current;\n    prevCountRef.current = count;\n\n    const handleClick = () => {\n        setCount(prevCount + count);\n    };\n\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={handleClick}>SetCount</button>\n        </div>\n    );\n}\n```\n\n这段代码实现的功能是，count 初始值为 1，点击按钮后累加到 2，随后点击按钮，总是用当前 count 的值和前一个 count 的值进行累加，得到新的 count 的值。\n\n`prevCountRef` 在 render 函数执行的过程中，与最新的 `count` state 进行了同步。由于在同步前，我们将该 ref 保存到函数作用域下的另一个变量 `prevCount` 中，因此我们总是能够获取到前一个 count 的值。\n\n同样的方法，我们可以用于保存任何值：某个 prop，某个 state 变量，甚至一个函数等。在后面的 Effects 部分，我们会继续使用 refs 为我们带来好处。\n\n## 每一帧可以拥有独立的 Effects\n\n如果弄清了前面的『每一帧拥有独立的变量』的概念，你会发现，若某个 useEffect/useLayoutEffect 有且仅有一个函数作为参数，那么每次 render 函数执行时该 Effects 也是独立的。因为它是在 render 函数中选择适当时机的执行。\n\n对于 `useEffect` 来说，执行的时机是完成所有的 DOM 变更并让浏览器渲染页面后，而 `useLayoutEffect` 和 class 组件中 `componentDidMount`, `componentDidUpdate `一致——在 React 完成 DOM 更新后马上同步调用，会阻塞页面渲染。\n\n如果 useEffect 没有传入第二个参数，那么第一个参数传入的 effect 函数在每次 render 函数执行是都是独立的。每个 effect 函数中捕获的 props 或 state 都来自于那一次的 render 函数。\n\n我们可以再观察一个例子：\n\n```jsx\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n        setTimeout(() => {\n            console.log(`You clicked ${count} times`);\n        }, 3000);\n    });\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>\n                Click me\n        </button>\n        </div>\n    );\n}\n``` \n\n在这个例子中，每一次对 `count` 进行改变，重新执行 render 函数后，延迟 3 秒打印 `count` 的值。\n\n如果我们不停地点击按钮，打印的结果是什么呢？\n\n我们发现经过延时后，每个 count 的值被依次打印了，他们从 0 开始依次递增，且不重复。\n\n如果换成 class 组件，尝试使用 `componentDidUpdate` 去实现，会得到不一样的结果：\n\n```jsx\ncomponentDidUpdate() {\n    setTimeout(() => {\n        console.log(`You clicked ${this.state.count} times`);\n    }, 3000);\n}\n```\n\n`this.state.count` 总是指向最新的 `count` 值，而不是属于某次调用 render 函数时的值。\n\n因此，在使用 useEffect 时，应当抛开在 class 组件中关于生命周期的思维。他们并不相同。在 useEffect 中刻意寻找那几个生命周期函数的替代写法，将会陷入僵局，无法充分发挥 useEffect 的能力。\n\n## 在比对中执行 Effects\n\nReact 针对 React Elements 前后值进行对比，只去更新 DOM 真正发生改变的部分。对于 Effects，能否有类似这样的理念呢？\n\n某个 Effects 函数一旦执行，函数内的副作用已经发生，React 无法猜测到函数相比于上一次做了哪些变化。但我们可以给 useEffect 传入第二个参数，作为依赖数组 (deps)，避免 Effects 不必要的重复调用。\n\n这个 deps 的含义是：当前 Effect 依赖了哪些变量。\n\n但有时问题不一定能解决。比如官网就有 [这样的例子](https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often)：\n\n```jsx\nconst [count, setCount] = useState(0);\n\nuseEffect(() => {\n    const id = setInterval(() => {\n        setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n}, [count]);\n```\n\n如果我们频繁修改 `count`，每次执行 Effect，上一次的计时器被清除，需要调用 `setInterval` 重新进入时间队列，实际的定期时间被延后，甚至有可能根本没有机会被执行。\n\n但是下面这样的实践方式也不宜采用：\n\n在 Effect 函数中寻找一些变量添加到 deps 中，需要满足条件：其变化时，需要重新触发 effect。\n\n按照这种实践方式，`count` 变化时，我们并不希望重新 `setInterval`，故 deps 为空数组。这意味着该 hook 只在组件挂载时运行一次。Effect 中明明依赖了 `count`，但我们撒谎说它没有依赖，那么当 `setInterval` 回调函数执行时，获取到的 `count` 值永远为 0。\n\n遇到这种问题，直接从 deps 移除是不可行的。静下来分析一下，此处为什么要用到 `count`？能否避免对其直接使用？\n\n可以看到，在 `setCount` 中用到了 `count`，为的是把 `count` 转换为 `count + 1` ，然后返回给 React。React 其实已经知道当前的 `count`，我们需要告知 React 的仅仅是去递增状态，不管它现在具体是什么值。\n\n所以有一个最佳实践：状态变更时，应该通过 setState 的函数形式来代替直接获取当前状态。\n\n```js\nsetCount(c => c + 1);\n```\n\n另外一种场景是：\n\n```jsx\nconst [count, setCount] = useState(0);\n\nuseEffect(() => {\n    const id = setInterval(() => {\n        console.log(count);\n    }, 1000);\n    return () => clearInterval(id);\n}, []);\n```\n\n在这里，同样的，当`count` 变化时，我们并不希望重新 `setInterval`。但我们可以把 `count` 通过 ref 保存起来。\n\n```jsx\nconst [count, setCount] = useState(0);\nconst countRef = useRef();\ncountRef.current = count;\n\nuseEffect(() => {\n    const id = setInterval(() => {\n        console.log(countRef.current);\n    }, 1000);\n    return () => clearInterval(id);\n}, []);\n```\n\n这样，`count` 的确不再被使用，而是用 ref 存储了一个在所有帧中共享的变量。\n\n另外的情况是，Effects 依赖了函数或者其他引用类型。与原始数据类型不同的是，在未优化的情况下，每次 render 函数调用时，因为对这些内容的重新创建，其值总是发生了变化，导致 Effects 在使用 deps 的情况下依然会频繁被调用。\n\n对于这个问题，[官网的 FAQ](https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies) 已经给出了答案：对于函数，使用 useCallback 避免重复创建；对于对象或者数组，则可以使用 useMemo。从而减少 deps 的变化。\n\n## 使用 ESLint 插件\n\n使用 ESLint 插件 `eslint-plugin-react-hooks@>=2.4.0`，很有必要。\n\n该插件除了帮你检查[使用 Hook 需要遵循的两条规则](https://zh-hans.reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level)外，还会向你提示在使用 useEffect 或者 useMemo 时，deps 应该填入的内容。\n\n如果你正在使用 VSCode，并且安装了 ESLint 扩展。当你编写 useEffect 或者 useMemo ，且 deps 中的内容并不完整时，deps 所在的那一行便会给出警告或者错误的提示，并且会有一个快速修复的功能，该功能会为你自动填入缺失的 deps。\n\n对于这些提示，不要暴力地通过 `eslint-disable` 禁用。未来，你可能再次修改该 useEffect 或者 useMemo，如果使用了新的依赖并且在 deps 中漏掉了它，便会引发新的问题。有一些场景，比如 useEffect 依赖一个函数，并且填入 deps 了。但是这个函数使用了 useCallback 且 deps 出现了遗漏，这种情况下一旦出现问题，排查的难度会很大，所以为什么要让 ESLint 沉默呢？\n\n尝试用上一节的方法进行分析，对于一些变量不希望引起 effect 重新更新的，使用 ref 解决。对于获取状态用于计算新的状态的，尝试 setState 的函数入参，或者使用 useReducer 整合多个类型的状态。\n\n## 使用 useMemo/useCallback\n\nuseMemo 的含义是，通过一些变量计算得到新的值。通过把这些变量加入依赖 deps，当 deps 中的值均未发生变化时，跳过这次计算。useMemo 中传入的函数，将在 render 函数调用过程被同步调用。\n\n可以使用 useMemo 缓存一些相对耗时的计算。\n\n除此以外，useMemo 也非常适合用于存储引用类型的数据，可以传入对象字面量，匿名函数等，甚至是 React Elements。\n\n```jsx\nconst data = useMemo(() => ({\n    a,\n    b,\n    c,\n    d: 'xxx'\n}), [a, b, c]);\n\n// 可以用 useCallback 代替\nconst fn = useMemo(() => () => {\n    // do something\n}, [a, b]);\n\nconst memoComponentsA = useMemo(() => (\n    <ComponentsA {...someProps} />\n), [someProps]);\n```\n\n在这些例子中，useMemo 的目的其实是尽量使用缓存的值。\n\n对于函数，其作为另外一个 useEffect 的 deps 时，减少函数的重新生成，就能减少该 Effect 的调用，甚至避免一些死循环的产生;\n\n对于对象和数组，如果某个子组件使用了它作为 props，减少它的重新生成，就能避免子组件不必要的重复渲染，提升性能。\n\n未优化的代码如下：\n\n```jsx\nconst data = { id };\n\nreturn <Child data={data}>;\n```\n\n此时，每当父组件需要 render 时，子组件也会执行 render。如果使用 `useMemo` 对 data 进行优化：\n\n```jsx\nconst data = useMemo(() => ({ id }), [id]);\n\nreturn <Child data={data}>;\n```\n\n当父组件 render 时，只要满足 id 不变，data 的值也不会发生变化，子组件也将避免 render。\n\n对于组件返回的 React Elements，我们可以选择性地提取其中一部分 elements，通过 useMemo 进行缓存，也能避免这一部分的重复渲染。\n\n在过去的 class 组件中，我们通过 `shouldComponentUpdate` 判断当前属性和状态是否和上一次的相同，来避免组件不必要的更新。其中的比较是对于本组件的所有属性和状态而言的，无法根据 `shouldComponentUpdate` 的返回值来使该组件一部分 elements 更新，另一部分不更新。\n\n为了进一步优化性能，我们会对大组件进行拆分，拆分出的小组件只关心其中一部分属性，从而有更多的机会不去更新。\n\n而函数组件中的 useMemo 其实就可以代替这一部分工作。为了方便理解，我们来看 *例五*：\n\n[![Edit 使用 useMemo 缓存 React Elements\n](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/goofy-grothendieck-tkmow?fontsize=14&hidenavigation=1&module=%2Fsrc%2FExample.js&theme=dark)\n\n```jsx\nfunction Example(props) {\n    const [count, setCount] = useState(0);\n    const [foo] = useState(\"foo\");\n\n    const main = (\n        <div>\n            <Item key={1} x={1} foo={foo} />\n            <Item key={2} x={2} foo={foo} />\n            <Item key={3} x={3} foo={foo} />\n            <Item key={4} x={4} foo={foo} />\n            <Item key={5} x={5} foo={foo} />\n        </div>\n    );\n\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={() => setCount(count + 1)}>setCount</button>\n            {main}\n        </div>\n    );\n}\n```\n\n假设 `<Item>` 组件，其自身的 render 消耗较多的时间。默认情况下，每次 setCount 改变 count 的值，便会重新对 `<Example>` 进行 render，其返回的 React Elements 中3个 `<Item>` 也重新 render，其耗时的操作阻塞了 UI 的渲染。导致按下 \"setCount\" 按钮后出现了明显的卡顿。\n\n为了优化性能，我们可以将 `main` 变量这一部分单独作为一个组件 `<Main>`，拆分出去，并对  `<Main>` 使用诸如 `React.memo` , `shouldComponentUpdate` 的方式，使 `count` 属性变化时，`<Main>` 不重复 render。\n\n```jsx\nconst Main = React.memo((props) => {\n    const { foo }= props;\n    return (\n        <div>\n            <Item key={1} x={1} foo={foo} />\n                <Item key={2} x={2} foo={foo} />\n                <Item key={3} x={3} foo={foo} />\n                <Item key={4} x={4} foo={foo} />\n                <Item key={5} x={5} foo={foo} />\n        </div>\n    );\n});\n```\n\n而现在，我们可以使用 `useMemo`，避免了组件拆分，代码也更简洁易懂：\n\n```jsx\nfunction Example(props) {\n    const [count, setCount] = useState(0);\n    const [foo] = useState(\"foo\");\n\n    const main = useMemo(() => (\n        <div>\n            <Item key={1} x={1} foo={foo} />\n            <Item key={2} x={2} foo={foo} />\n            <Item key={3} x={3} foo={foo} />\n            <Item key={4} x={4} foo={foo} />\n            <Item key={5} x={5} foo={foo} />\n        </div>\n    ), [foo]);\n\n    return (\n        <div>\n            <p>{count}</p>\n            <button onClick={() => setCount(count + 1)}>setCount</button>\n            {main}\n        </div>\n    );\n}\n```\n\n## 惰性初始值\n\n对于 state，其拥有 [惰性初始化的方法](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state)。可能有人不明白它的作用。\n\n\n`someExpensiveComputation` 是一个相对耗时的操作。如果我们直接采用\n\n```jsx\nconst initialState = someExpensiveComputation(props);\nconst [state, setState] = useState(initialState);\n```\n\n注意，虽然 `initialState` 只在初始化时有其存在的价值，但是 `someExpensiveComputation` 在每一帧都被调用了。只有当使用惰性初始化的方法：\n\n```jsx\nconst [state, setState] = useState(() => {\n    const initialState = someExpensiveComputation(props);\n    return initialState;\n});\n```\n\n因 `someExpensiveComputation` 运行在一个匿名函数下，该函数当且仅当初始化时被调用，从而优化性能。\n\n我们甚至可以跳出计算 state 这一规定，来完成任何昂贵的初始化操作。\n\n```jsx\nuseState(() => {\n    someExpensiveComputation(props);\n    return null;\n});\n```\n\n\n## 避免滥用 refs\n\n当 `useEffect` 的依赖频繁变化，你可能想到把频繁变化的值用 ref 保存起来。然而，useReducer 可能是更好的解决方式：使用 dispatch 消除对一些状态的依赖。[官网的 FAQ](https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often) 有详细的解释。\n\n最终可以总结出这样的实践：\n\nuseEffect 对于函数依赖，尝试将该函数放置在 effect 内，或者使用 useCallback 包裹；useEffect/useCallback/useMemo，对于 state 或者其他属性的依赖，根据 eslint 的提示填入 deps；如果不直接使用 state，只是想修改 state，用 setState 的函数入参方式（`setState(c => c + 1)`）代替；如果修改 state 的过程依赖了其他属性，尝试将 state 和属性聚合，改写成 useReducer 的形式。当这些方法都不奏效，使用 ref，但是依然要谨慎操作。\n\n## 避免滥用 useMemo\n\n使用 useMemo 当 deps 不变时，直接返回上一次计算的结果，从而使子组件跳过渲染。\n\n但是当返回的是原始数据类型（如字符串、数字、布尔值）。即使参与了计算，只要 deps 依赖的内容不变，返回结果也很可能是不变的。此时就需要权衡这个计算的时间成本和 useMemo 额外带来的空间成本（缓存上一次的结果）了。\n\n此外，如果 useMemo 的 deps 依赖数组为空，这样做说明你只是希望存储一个值，这个值在重新 render 时永远不会变。\n\n比如：\n```jsx\nconst Comp = () => {\n    const data = useMemo(() => ({ type: 'xxx' }), []);\n    return <Child data={data}>;\n}\n```\n可以被替换为：\n```jsx\nconst Comp = () => {\n    const { current: data } = useRef({ type: 'xxx' });\n    return <Child data={data}>;\n}\n```\n甚至：\n```jsx\nconst data = { type: 'xxx' };\nconst Comp = () => {\n    return <Child data={data}>;\n}\n```\n\n此外，如果 deps 频繁变动，我们也要思考，使用 useMemo 是否有必要。因为 useMemo 占用了额外的空间，还需要在每次 render 时检查 deps 是否变动，反而比不使用 useMemo 开销更大。\n\n\n## 受控与非受控\n\n在一个自定义 Hooks，我们可能有这样一段逻辑：\n\n```jsx\nuseSomething = (inputCount) => {\n    const [ count, setCount ] = setState(inputCount);\n};\n```\n\n这里有一个问题，外部传入的 `inputCount` 属性发生了变化，使其与 `useSomething` Hook 内的 `count` state 不一致时，是否想要更新这个 `count` ？\n\n默认不会更新，因为 useState 参数代表的是初始值，仅在 `useSomething` 初始时赋值给了 `count` state。后续 `count` 的状态将与 `inputCount` 无关。这种外部无法直接控制 state 的方式，我们称为非受控。\n\n如果想被外部传入的 props 始终控制，比如在这个例子中，`useSomething` 内部，`count` 这一 state 的值需要从 `inputCount` 进行同步，需要这样写：\n\n```jsx\nuseSomething = (inputCount) => {\n    const [ count, setCount ] = setState(inputCount);\n    setCount(inputCount);\n};\n```\n\n`setCount`后，React 会立即退出当前的 render 并用更新后的 state 重新运行 render 函数。这一点，[官网文档](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops) 是有说明的。\n\n在这种的机制下，state 由外界同步的同时，内部又有可能通过 setState 来修改 state，可能引发新的问题。例如 `useSomething` 初始时，count 为 0，后续内部通过 `setCount` 修改了 `count` 为 1。当外部函数组件的 render 函数重新调用，也会再一次调用 `useSomething`，此时传入的 `inputCount` 依然是 0，就会把 `count` 变回 0。这很可能不符合预期。\n\n遇到这样的问题，建议将 `inputCount` 的当前值与上一次的值进行比较，只有确定发生变化时执行 `setCount(inputCount)` 。\n\n当然，在特殊的场景下，这样的设定也不一定符合需求。[官网的这篇文章](https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html) 有提出类似的问题。\n\n## 实践：useSlider\n\n通过一个滑动选择器自定义 hook `userSlider` 的实现，我们可以回答上面的这个问题，顺便对本文做一个总结。\n\n![image](https://p1.music.126.net/ZtmN00eM49yWDirpRFRkyg==/109951164669603891.png)\n\n`userSlider` 需要实现的逻辑是：按住滑动选择器的圆形手柄区域并拖动可以调节数值大小，数值范围为 0 到 1。\n\n`userSlider` 只负责逻辑的实现，UI 样式由组件自行完成。为了模拟真实业务，另外通过文本展示了当前的数值。并有几个按钮用于切换数值的初始值，这是为了切换分类后，当前的滑动选择器需要重置到某个数值。\n\n按照常规的逻辑，我们实现了以下代码：\n\n[![Edit useSlider 问题](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/useslider-wenti-imji7?fontsize=14&hidenavigation=1&module=%2Fsrc%2FuseSlider.js&theme=dark)\n\n当前的问题是，`useEffect` 涉及到多个 state 的获取与计算。导致鼠标按下、移动、弹起的几个操作中因为对 stata 的修改，`useEffect` 频繁刷新，且涉及到了鼠标按下、移动、弹起事件监听的取消与重新绑定，这带来了性能问题以及较难观察到的 BUG。\n\n和前面的 `setInterval` 例子相似，我们不希望在状态变动时，刷新 `useEffect`。由于此处涉及到多个状态：是否滑动中、鼠标位置、上一次鼠标的问题、选择器的可滑动宽度，如果整合到一个 `state` 中，会面临代码不清晰，缺少内聚性的问题，我们尝试用 `useReducer` 做一次替换。\n\n```jsx\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case \"start\":\n            return {\n                ...state,\n                lastPos: action.x,\n                slideRange: action.slideWidth,\n                sliding: true\n            };\n        case \"move\": {\n            if (!state.sliding) {\n                return state;\n            }\n            const pos = action.x;\n            const delta = pos - state.lastPos;\n            return {\n                ...state,\n                lastPos: pos,\n                ratio: fixRatio(state.ratio + delta / state.slideRange)\n            };\n        }\n        case \"end\": {\n            if (!state.sliding) {\n                return state;\n            }\n            const pos = action.x;\n            const delta = pos - state.lastPos;\n            return {\n                ...state,\n                lastPos: pos,\n                ratio: fixRatio(state.ratio + delta / state.slideRange),\n                sliding: false\n            };\n        }\n        default:\n            return state;\n    }\n};\n\n//...\n\nconst handleThumbMouseDown = useCallback(ev => {\n    const hotArea = hotAreaRef.current;\n    dispatch({\n        type: \"start\",\n        x: ev.pageX\n      slideWidth: hotArea.clientWidth\n    });\n}, []);\n\nuseEffect(() => {\n    const onSliding = ev => {\n        dispatch({\n            type: \"move\",\n            x: ev.pageX\n        });\n    };\n    const onSlideEnd = ev => {\n        dispatch({\n            type: \"end\",\n            x: ev.pageX\n        });\n    };\n    document.addEventListener(\"mousemove\", onSliding);\n    document.addEventListener(\"mouseup\", onSlideEnd);\n\n    return () => {\n        document.removeEventListener(\"mousemove\", onSliding);\n        document.removeEventListener(\"mouseup\", onSlideEnd);\n    };\n}, []);\n```\n\n这样处理后，effect 只要执行一次即可。\n\n接下来还有一个问题没有处理，目前 `initRatio` 是作为初始值传入的，`useSlider` 内部的 ratio 是不受外部控制的。\n\n以一个音乐均衡器的设置为例：当前滑动选择器代表的是低频端（31）的增益值，用户通过拖动滑块可以设置这个值的大小（-12 到 12 dB 范围，我们设置到了 3 dB）。同时我们提供了一些预设选项，一旦选择预设选项，如『流行』风格，当前滑块需要重置到特定值 -1 dB。为此， `useSlider` 需要提供控制状态的方法。\n\n![image](https://p1.music.126.net/AHuWUMbk9w3RiNoKPuznLw==/109951164669651478.png)\n\n根据前一节的介绍，在 `useSlider` 的开头，我们可以将属性 `initRatio` 的当前值与上一次的值进行比较，若发生变化，则执行 `setRatio`。但仍然有场景无法满足：用户选择了『流行』这一预设，然后拖动滑块进行了调节，之后又重新选择『流行』这一预设，此时 `initRatio` 没有任何变化，但我们期望 ratio 重新变为 `initRatio`。\n\n解决这个问题的办法是，在 `useSlider` 内部添加一个 `setRatio` 方法。\n\n```jsx\nconst setRatio = useCallback(\n    ratio =>\n        dispatch({\n            type: \"setRatio\",\n            ratio\n        }),\n    []\n);\n```\n\n将该方法输出供外部用于对 ratio 控制。`initRatio` 不再控制 ratio 的状态，仅用于设置初始值。\n\n可以看下最终的实现方案：\n\n[![Edit useSlider 最终版](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/useslider-zuizhongban-tun1t?fontsize=14&hidenavigation=1&module=%2Fsrc%2FuseSlider.js&theme=dark)\n\n该方案中，除了完成以上需求，还支持在选择器的其他区域点击直接跳转到对应的数值；支持设定选择器为垂直还是水平方向。供大家参考。\n\n## 结束语\n\n忘掉 class 组件的生命周期，重新审视函数式组件的意义，是用好 React Hooks 的关键一步。希望这篇文章能帮助大家进一步理解并获取到一些最佳实践。当然，不同的 React Hooks 使用姿势可能带来不同的最佳实践，欢迎大家交流。\n\n## 相关资料\n\n[A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)"
        },
        {
          "id": "rxjs-on-the-netease-cloud-music-desktop",
          "metadata": {
            "permalink": "/rxjs-on-the-netease-cloud-music-desktop",
            "source": "@site/blog/rxjs-on-the-netease-cloud-music-desktop/index.md",
            "title": "云音乐桌面端基于 RxJs 的数据层探索",
            "description": "前言",
            "date": "2020-01-01T10:00:00.000Z",
            "formattedDate": "2020年1月1日",
            "tags": [
              {
                "label": "rxjs",
                "permalink": "/tags/rxjs"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 35.105,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "rxjs-on-the-netease-cloud-music-desktop",
              "title": "云音乐桌面端基于 RxJs 的数据层探索",
              "authors": "auver",
              "date": "2020-01-01T10:00",
              "tags": [
                "rxjs",
                "javascript"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "React Hooks 最佳实践",
              "permalink": "/react-hooks-best-practices"
            },
            "nextItem": {
              "title": "Observable的冷与热",
              "permalink": "/hot-vs-cold-observables"
            }
          },
          "content": "## 前言\n\n网易云音乐 PC/MAC/Linux 这三大桌面端，均采用了在原生应用中嵌入前端页面的方式。\n\n通俗地说，就是将一个本地的 HTML 页面在浏览器中打开，但这个浏览器内嵌在云音乐桌面应用内。我们云音乐前端技术团队负责开发这个 HTML 页面，需要在这个页面中使用 JavaScript 相关技术绘制界面，并控制这个页面的交互。播放器、桌面歌词等内容则采用原生技术开发，并在 JS 中注入接口，以供前端调用。\n\n我们需要在这个单一的页面中，为用户提供桌面应用级的体验。在现有的方案中，我们也遇到一些应用体验不佳、开发效率低的问题。在最近一年里，我们也在寻找一些更好的解决方案，期望做得比以前更好。我们调研了一些解决方案，最终决定引入 RxJs，设计一套全新的数据层。\n\n本文会以云音乐桌面端的场景为例，先介绍为了实现桌面应用级的体验，我们的目标是什么，再看看过去我们为了这些目标面临了哪些挑战，最后谈到我们目前在做的，使用 RxJs 应对这些挑战的一些探索。\n\n<!-- truncate -->\n\n## 我们的目标\n\n### 单页\n\n首先，作为一个桌面端应用主界面的构成，任何交互操作中不能出现空白的画面；数据层的数据也需要持续保留，因此这必须是一个单页页面。\n\n### 本地缓存\n\n例如在歌单场景中，需要一套缓存机制，保存歌单中歌曲的基本信息，以便在播放歌曲、下载歌曲时，避免重复向服务端请求歌曲的详情数据。特别是一些歌单，歌曲数量可以多达一万首，这套机制尤为重要。\n\n### 持久化\n\n最基本的，例如需要对播放列表进行存储，以便用户在下次打开云音乐时还能继续使用上次关闭前的播放列表。\n\n若想继续提升用户体验，对于用户创建的歌单，作为用户高频访问的内容，也需要进行持久化的存储，从而提升歌单的访问速度，以减少用户的等待时间。\n\n### 内存管理\n\n常规的 web 应用或许不需要考虑这方面的问题。但是，作为桌面端应用，当用户一直未关闭应用，并访问了几百上千个页面，如果不进行内存管理，这些页面缓存的数据，一直存放着，那么此处应用程序也许会发生崩溃。我们需要尽量完美的内存控制，以保持我们作为桌面应用的稳定性，当然这很难。\n\n![image](https://p1.music.126.net/zVyN-jEv9aMNUceYnTDvIA==/109951164353284246.png)\n\n## 代码层面上的挑战\n\n### 关联数据的处理\n\n![image](https://p1.music.126.net/FyX_MlwrEEsi5stgqXHQxg==/109951164353006800.jpg)\n\n以首页的推荐歌单为例，这是一个有序列表，列表中存放的是各个歌单数据。\n\n直接使用下方这样的树状结构进行存放，展示起来很方便。\n\n```js\nlist = [{\n    'id': 54321,\n    'name': '[华语私人订制] 你爱的华语好歌都在这儿',\n    'copywriter': '编辑推荐：无论新歌老歌，都是耐听的华语好歌',\n    'playCount': 23298238,\n    'trackCount': 35,\n    'coverImgUrl': 'https://p3.music.126.net/KEBE7CU-y2lInkHBcgzpUA==/109951164173101961.jpg'\n}, {\n    'id': 1234,\n    'name': '[一周原创发现] 上周原创君发现的好歌',\n    'copywriter': '编辑推荐： 遇见全新面孔，邂逅熟悉声线',\n    'playCount': 11565127,\n    'trackCount': 30,\n    'coverImgUrl': 'https://p3.music.126.net/09o_XZbuG0TFWnNGAKuV5w==/109951164321476771.jpg'\n},\n    ...\n];\n```\n\n但是如果其中有一些歌单，同时是当前用户创建的歌单，按上面这个方法又存放了一份歌单数据。当用户修改这个歌单时，如何确保两份歌单数据都能得到更新？\n\n有一种方法是，使用 map 的结构，`id` 为 `key`，数据为 `value`。不同列表中对这个歌单的数据，都是对 map 中这个歌单的引用。也就是对同一个数据项，做了多重索引。\n\n```js\nplaylistMap = {};\nplaylistMap[54321] = {\n    'id': 54321,\n    'name': '[华语私人订制] 你爱的华语好歌都在这儿',\n    'copywriter': '编辑推荐：无论新歌老歌，都是耐听的华语好歌',\n    'playCount': 23298238,\n    'trackCount': 35,\n    'coverImgUrl': 'https://p3.music.126.net/KEBE7CU-y2lInkHBcgzpUA==/109951164173101961.jpg'\n};\nplaylistMap[1234] = {\n    'id': 1234,\n    'name': '[一周原创发现] 上周原创君发现的好歌',\n    'copywriter': '编辑推荐： 遇见全新面孔，邂逅熟悉声线',\n    'playCount': 11565127,\n    'trackCount': 30,\n    'coverImgUrl': 'https://p3.music.126.net/09o_XZbuG0TFWnNGAKuV5w==/109951164321476771.jpg'\n};\nlist = [playlistMap[54321], playlistMap[1234]];\n```\n\n这样对视图来说，依然是树状结构，当若修改了 map 或者 list 里面的某个数据，另外几处也会得到修改，因为完全是相同的引用。\n\n但要想让视图层关联的内容刷新，你需要再加一套事件机制，提示视图去刷新。发布事件，视图层订阅事件，两者缺一不可。\n\n在实际的场景中，情况会更复杂。例如歌单里面嵌套了创作者、歌曲列表这样的数据，歌曲列表有序存放着歌曲，单个歌曲则可以嵌套多个歌手，嵌套专辑数据。在歌单详情页中，这些数据均需要展示。\n\n如果使用 React + Redux 这样的方案，基于不可变数据的原则，这种方式就不适用了。我们修改了一个数据项，需要复制一个新的对象，所有引用到这个数据项的地方都要用新的对象去替换，这是非常繁琐的。\n\n因此有一些方案中，提出对数据保持扁平，遇到这种层层嵌套的数据，进行范式化处理。前面提到的这种引用，我们改为存储 `id` 来描述引用关系。这样数据项只在一个地方定义，当其需要更新的话无需在多处改变。这是个不错的想法，但这不能解决数据更新后视图同步刷新的问题。你需要在多个 reducer 中处理这些数据，有些繁琐，代码也不是特别清晰。\n\n### 关联的计算\n\n如果我们说，关联的数据指的是数据间能够用引用关系去描述关联。那么实际上还有一种关联。例如，用户的会员状态，与一首歌曲，表面上并没有引用关系，但隐藏的情况是：歌曲中会有一些内容用来描述用户对这个歌曲拥有的权限，例如能否播放这个歌曲，而有一些歌曲是仅限会员播放的。当用户的会员状态变化时，需要把歌曲权限更新到最新状态。\n\n其实这代表了一种情况，某个事件发生了，需要推动一系列数据去变更，或者说需要对其他的一系列数据做一次新的计算。`a = b + c`，b 或 c 变化的时候需要重新计算 a。传统的做法，是 b 发生变化，通知 a 模块，a 需要监听到这条消息，重新去获取 b 和 c 的值，从而重新计算。c 发生变化，亦是如此。其缺点就是比较麻烦，可读性也不强。\n\n当然有更复杂的情况，比如在 `a = b + c` 中，希望 b 和 c 均在经历一次变动过后，才重新计算 a。此时就需要写另外一段代码来处理这个问题了。\n\n### 逻辑复杂\n\n查询同一种数据，可能从缓存中获取，那是同步的。如果是 Fetch 请求，那是异步的，业务代码编写需要考虑两种情况。大致的代码如下：\n```js\nconst data = getItemInCache();\nif (data) {\n    render();\n} else {\n    getItem();\n}\n\non('itemGet', () => {\n    render();\n});\n```\n如果按照获取数据的来源分类，Fetch 请求，DB，LocalStorage，获取文件缓存，这些都是拉的操作，也就是获取数据的操作。WebSocket，用户的输入，则是推的操作，是数据的更新通知。他们的代码是这样的：\n```js\n// 拉\ngetSomething().then(() => {\n    // do\n});\n\n// 推\non('somethingPush', () => {\n    // do\n});\n```\n有时对同一种数据进行更新，但是因为推和拉不同的来源，需要两份代码，加大了代码编写的复杂度。\n\n对于这类问题，有如下大致的解决方式：\n```js\nconst changeTodo = todo => {\n    dispatch({type: 'updateTodo', payload: todo});\n}\n\nconst changefromDOMEvent = () => {\n    const todo = formState\n    changeTodo(todo);\n}\n\nconst changefromWebSocket = () => {\n    const todo = fromWS\n    changeTodo(todo);\n}\n```\n但是这种方式还有个问题，我们没法清楚地看到一条数据的来龙去脉。此外，事件的发布与订阅者，经常位于不同的模块中，需要封装良好的自定义事件，以便事件的订阅者分辨事情的来源，以及它需要去做什么。\n\n### 内存管理\n\n这个事情很棘手。在目前版本的云音乐桌面端中，我们没有找到有效的办法去管理，只能设置定时器，手动去寻找一些可能无用的缓存数据，然后去清理他们。\n\n## 我们的应对\n\n首先需要说明的是，以下内容是我们目前在做的，利用 RxJs 解决这些问题的一些探索。离这些内容正式上线还有一段路要走。如果读者对这些方案存在疑问，欢迎与我们交流。\n\n假设读者已经对 RxJs 有一些简单的了解（学习 RxJs 相关内容可以移步到[官网](https://rxjs-dev.firebaseapp.com/guide/overview)）。比如说，对于上面 `a = b + c` 这个问题，你需要知道 RxJs 里可以这样做：\n```js\nconst b$ = new Rx.Subject();\nconst c$ = new Rx.Subject();\nconst a$ = b$.combineLatest(c$, (b, c) => b + c);\na$.subscribe(c => console.log(`a=${a}`));\nb$.next(1);\nc$.next(1);\n// a=2\nc$.next(2);\n// a=3\nb$.next(10);\n// a=12\n```\n\n我们看看 RxJs 为我们带来了什么。\n\n### RxJs 处理复杂的逻辑\n\n对于查询一份数据遇到的同步与异步两种情况，我们可以做如下的事情：\n```js\nconst data$ = () => {\n    if (cache) {\n        return Rx.of(cache);\n    } else {\n        return Rx.fromPromise(fetch(url));\n    }\n}\ndata$.subscribe(data => {\n    // do\n})；\n```\n可以看到，我们查询这份数据，优先读取缓存，这是同步的操作；如果缓存无效，进行了一次异步获取数据的操作。视图层只需要执行一次对数据的订阅即可。\n\n接下来处理数据多种来源中推与拉两种不同方式的问题。\n\n首先，RxJs 支持将所有内容封装为数据流。无论是 Fetch 请求，DB，LocalStorage，获取文件缓存的操作，还是 WebSocket，用户输入的事件，统统可以封装成数据流，然后交给视图层去订阅，而不需要在不同数据来源拿到数据后，考虑怎么交给视图层。\n\n```js\nconst dataFromWebSocket$ = Rx.fromEvent(ws, 'message');\n\ndata$.pipe(\n    merge(dataFromWebSocket$)\n).subscribe(data => {\n    // do\n})；\n```\n把推送信息，和主动查询数据的两个流合并起来，供视图去订阅。不管是推还是拉的操作，从代码编写的角度，都是一个拉取的方式。因为我们写出了类似表达式的效果，一个数据流可以由其他数据流通过多种运算符来组合、转换得到。形似 `a = b + c`。但其实际表达的意思，却是\n```js\non('b changed', (newB) => {\n    a = newB + c;\n    // dispatch event\n});\non('c changed', (newC) => {\n    a = b + newC;\n    // dispatch event\n});\n```\n也就是其实是一个推送的过程。\n\n视图层只需要去订阅数据流，而不需要考虑数据要怎么获取，数据到时候是怎么推送过来的，视图层只要专注于自己的逻辑就可以了。\n\n此外，不管是多么复杂的逻辑，都能在 RxJs 中找到合适的操作运算符，由最基础的数据流组合、转换得到复杂的数据流供视图去订阅。例如之前提到的，在 `a = b + c` 中，希望 b 和 c 均在经历一次变动过后，才重新计算 a，我们就可以使用如下的操作符。\n\n==TODO==\n\n总结一下，我们以推荐歌单页面为例，看看其中视图与数据流大致的设计思路。\n\n当用户访问了推荐歌单页面，视图中会执行对获取推荐歌单这条数据流的订阅。此时，这条数据流开始流动。因为是第一次获取推荐歌单，我们还没有缓存这一部分的数据，我们去发送 Fetch 请求，Fetch 请求得到的数据，在经过一些格式化操作后，会存放为缓存。但是，我们最后提供给视图订阅的，并不是这条格式化后的数据，而是经过包装的一条新的数据流，这条数据流是在格式化的数据基础上，又与其他可能引起这些歌单的数据产生变化的数据流组合而来。\n\n当推荐歌单这一部分数据中，任意歌单数据发生变化，都会引起数据流新的流动，从而去推动视图进行变更。\n\n![image](https://p1.music.126.net/HIVj-3-QHwnlLmoUqlXgtQ==/109951164352912137.png)\n\n另外需要注意，视图只要做一次对数据流的订阅即可，而不需要执行类似 dispatch action 这样的操作。除非是增加、删除、修改这样的操作，也就是从视图层面进行的数据的写入，需要做一个 dispatch action 的操作。这也简化了视图层的一些逻辑，视图不需要关心，第一次数据是怎么来的，需要拉取哪部分的数据。\n\n### 选择懒执行还是预热\n\n从前面就可以看到，视图使用数据，只需要对数据流进行订阅。反过来思考，当视图没有对数据流进行过订阅时，数据流会不会流动呢？以一段代码为例：\n```js\nconst promise = new Promise((resolve) => {\n    console.log('Hello');\n    resolve(1);\n});\n```\n代码运行后会输入 `Hello` 。但换成 RxJs 的 `Observable`：\n\n```js\nconst foo$ = Rx.create((observer) => {\n    console.log('Hello');\n    observer.next(1);\n    observer.next(2);\n    observer.next(3);\n});\n```\n这段代码没有任何输出。\n\n与 Promise 不同，当 `foo$` 未被订阅，内部是未执行的状态，数据流并没有开始流动。\n\n想想这样的好处。首先这是前面提到的，视图层只需要订阅数据流而不需要额外操作的前提。此外，在视图未订阅的情况下，推送类型的数据是不流动的，符合我们的预期，避免了无用的请求和未知的副作用。\n\nRxJS 让我们能够精确执行向确实存在的视图的数据流推送。\n\n当然，如果需要，我们也可以做一些预热的操作，让数据流提前流动。比如预先去 fetch 来获取到数据，等到视图订阅时，能够立刻拿到数据，提升应用程序的响应速度。使用诸如 `publish` 和 `connect` 的操作符就可以预热。这里不再详细阐述。\n```js\nconst source = Rx.interval(1000);\nconst example = source.pipe(\n    publish()\n);\nexample.connect();\n```\n\n### 不需要集中的数据管理\n\nRedux 为什么是单一 Store。其中一个原因是需要从整体的 state 结构上检出变化的部分。\n\n但 RxJs 不需要，变更过程是精确的。数据从数据管道一直流动到视图上，而没有变化的部分就不会流动。\n\n至于别的原因，例如方便同构应用开发，方便实现撤销/重做功能。在我们的云音乐桌面端场景上也没有这种需要。\n\n因此，我们可以按业务划分 module 。且每个 module 中向视图暴露的其实也是一条一条数据流，你可以去订阅这些数据流。例如获取推荐歌单的数据推送，这就是歌单这个 module 中提供的一条数据流，而它由其他多个数据流组合而成。\n\n如果是单一 Store，我们需要指定 action 去修改 state，需要区分这个 action 修改的是 state 内的具体哪个部分。\n\n而实际的情况是，在多个 module 中，大部分的数据是不需要跨域 module 处理的，我们关心数据在单个 module 中的流动即可；少部分情况下我们用 RxJs 的操作运算符进行组合、转换等也可以完成不同 module 间的关联数据计算。在数据流的组合操作中，天然地表明了数据流动的姿态，无需 action 来标记修改的部分。\n\n### 数据管理的详细设计\n\n前面介绍了那么多 RxJs 的好处，并说明了数据从顶部到视图层的大致流向，接下来我们需要设计，如何利用 RxJs 存放数据，并提供优质的数据流供视图订阅。\n\n对于复杂的、嵌套的数据，我们考虑做一些范式化的操作。我们存储的是扁平的数据，通过对id的存储来描述不同类型的数据的引用关系。\n\n例如歌单项的存放，一个歌单的数据看上去是这样的：\n```js\nconst playlistItem = {\n    name: 'xxx',\n    id: '123',\n    cloudTrackCount: 0,\n    commentCount: 123,\n    creator: {\n        id: '1',\n        name: 'aaa'\n    },\n    ...\n    trackCount: 2,\n    trackIds: ['12345', '14567'],\n    tracks: [{\n        id: '12345',\n        name: 'abcde',\n        ...\n    }, {\n        id: '14567',\n        name: 'adefg',\n        ...\n    }]\n};\n```\n我们需要对其进行范式化处理，例如使用 `creatorId` 来描述关联的是哪个用户。关联的用户数据，则作为单独的数据项存放。处理后的歌单数据是这样的：\n```js\nconst playlistItem = {\n    name: 'xxx',\n    id: '123',\n    cloudTrackCount: 0,\n    commentCount: 123,\n    creatorId: '1',\n    ...\n    trackCount: 2\n};\nconst creatorItem = {\n    id: '1',\n    name: 'aaa'\n};\nconst trackList = {\n    id: 'playlist-123',\n    list: ['12345', '14567']\n};\nconst trackItem1 = {\n    id: '12345',\n    name: 'abcde',\n    ...\n};\nconst trackItem2 = {\n    id: '14567',\n    name: 'adefg',\n    ...\n};\n```\n根据实际业务中遇到的各种场景，我们总结了常见的数据关联方式，从而提出范式化处理中的一些约定：\n\n- 不同类型的数据声明不同的容器。同一类型的数据存放在同一种容器的实例中。这一类型的数据可以作为一个 entity 来看待；\n\n- 将同类型的 entity 存储在 Collection 集合中，其中每个 entity 的主键 `primary` 作为 `key`，entity本身作为 `value`；\n\n- 任何对单个 entity 的引用都应该根据存储的 `primary` 来表示。需要使用时，从 Collection 中查询获取；\n\n- 针对例如歌单中的歌曲列表这样的有序列表，再定义一个List 容器，实例化的 `list` 中应该存储 entity 的 `primary` 来引用他们。将 `list` 也存储在 Collection 集合中便于之后查找。\n\n在声明某一类型的容器时，我们可以使用诸如 JSON Schema 的方式来描述数据的格式，以便于进行数据校验、格式化，持久化等工作。额外添加一些属性，用数据流描述对其他类型数据的关联。\n\n声明完这些内容后，接下来的使用就方便了。在容器的实例中，对其中任意属性进行修改，都会因为数据流的存在，流动到被其依赖的数据项中，进行同步的更新，并最终流动到视图中，视图需要什么数据项就订阅什么数据项，数据项更新的时候，或者关联的数据更新的时候，均会自动流动到视图上。\n\n实际使用时，我们会涉及到向 Collection 查找符合条件的 entity；在 List 中 `slice()` 取到列表的一部分内容，以满足视图中分页的场景；针对某个 entity 订阅其中一部分属性的变化。我们使用 RxJs 的操作符实现一些自定义的方法即可。\n\n根据以上思路，得到的设计方案大致是这样的：\n\n![image](http://p1.music.126.net/eclTgAaADkT0j9qvoiMxiQ==/109951164352510560)\n\n以歌曲为例说明这套方案的使用方式，首先声明数据格式：\n```js\nclass Track extends BaseStore {\n    static schema = {\n        type: 'object',\n        properties: {\n            name: {\n                type: 'string',\n                default: ''\n            },\n            id: {\n                type: 'string',\n                primary: true\n            },\n            artistId: {\n                type: 'string'\n            }\n        },\n        required: ['id']\n    }\n\n    static views = {\n        get artist() {\n            return this.artistId$.pipe(\n                switchMap(id => (id\n                    ? ArtistStore.findOne(id).$.pipe(\n                        map(([item]) => (item\n                            ? item.data\n                            : null))\n                    )\n                    : Rx.of()))\n            );\n        }\n    }\n}\n\nclass TrackCollection extends CollectionStore {\n    static entity = Track\n}\nconst trackCollection = new TrackCollection();\n```\n\n注意 `Track.views` 的逻辑，这里的思路是，通过 `views` 方法表明对关联的 `artist` 数据的依赖。\n\n`artistId$` 表示订阅歌曲中 `artist` 数据的变动。这种只想订阅数据项中某个属性的变动，最简单的实现方式，就是使用 `distinctUntilKeyChanged` 操作符。\n\n> 返回 Observable，它发出源 Observable 发出的所有与前一项不相同的项，使用通过提供的 key 访问到的属性来检查两个项是否不同。\n\n通过这种方法，我们将不再需要类似 [reselect](https://github.com/reduxjs/reselect) 这样的工具。\n\n\n考虑使用诸如 `trackCollection.findOne(id).views('artist').$` 方法来订阅某个歌曲数据，使歌曲本身的变化，以及歌曲对应的 `artist` 艺人数据变化时，均能得到新的数据流动。也就是查找到的歌曲数据本身和 `views` 指定的 `artist` 查询的数据流，会合并得到新的数据流。\n这里可以使用 RxJs 的 `combineLatest` 操作符来实现具体的逻辑。\n\n> combineLatest 结合所有输入 Observable 参数的值. 顺序订阅每个 Observable，每当任一输入 Observable 发出，收集每个输入 Observable 的最新值组成一个数组。\n\n```js\nif (views && views.length) {\n    return Rx.combineLatest(\n        x.all$,\n        ...views.map(v => x.views[`${v}$`]).filter(Boolean)\n    );\n}\n```\n\n其中 `x` 是查询到的 entity，`x.all$` 代表了 entity 本身的数据变动，`x.views` 中以 `$` 为后缀的属性则代表了具体某个 view 属性，数据变动产生的数据流。\n\n类似的方式，考虑在 List 中添加 `itemViews` 相关的逻辑。\n\n```js\nclass TrackList extends ListStore {\n    static schema = {\n        type: 'object',\n        properties: {\n            id: {\n                type: 'string',\n                primary: true\n            },\n            list: {\n                type: 'array',\n                items: {\n                    type: 'string'\n                }\n            },\n            total: {\n                type: 'number'\n            }\n        }\n    }\n\n    static itemViews = {\n        items(id) {\n            return trackCollection\n                .findOne(id).views('artist')\n                .$.pipe(\n                    map(([item]) => item)\n                );\n        }\n    }\n}\n\nclass TrackListCollection extends CollectionStore {\n    static entity = TrackListStore\n}\n\nconst trackListCollection = new TrackListCollection();\n```\n随后我们可以往 `trackListCollection` 插入数据，而对其数据的订阅，则可以有类似这样的操作：\n```js\ntrackListCollection.findOne('newsong').exec().then(([result]) => {\n    result.join().views('items').$.subscribe(\n        data => data.items.forEach(i => render({ ...i.data, ...i.views }))\n    )\n});\n```\n\n通过这样的方法，可以获取到某个歌曲列表，并在任意歌曲和他们的歌手数据变动时，均有数据流动，得到最新的数据。实现思想与 `findOne().$` 基本一致，此处不再阐述。\n\n### 内存管理\n\n因为对于数据，均是通过对数据流进行订阅来获取的。当切换页面的时候，视图层会执行对某些数据流取消订阅的操作，同时也会影响关联的数据流的订阅状态。如图所示，灰色歌曲被视图取消订阅，关联的专辑或歌手数据流也能分析出是否继续被订阅：\n\n![image](https://p1.music.126.net/EagkhHTLRP7mYzoTGyLOAw==/109951164353281694.png)\n\n因此，对任意数据流来说，是否被订阅，可以表明视图是否在使用它。当某些数据有很长一段时间没有被订阅时，就考虑删除操作以回收内存。\n\n我们可以开设一个定时器，去找已经取消订阅，且取消订阅时间最长的数据流，优先回收它，使缓存的数据稳定在一个能被接受的内存大小。\n\n不过RxJs并没有直接提供获取到某个数据流的订阅数这样的方法，需要自己去实现一下。这是主要的思路：\n```js\nnew$ = Rx.Observable.create((subscriber) => {\n    const subscription = old$.subscribe(subscriber);\n    counter++;\n    return () => {\n        subscription.unsubscribe();\n        counter--;\n    };\n});\n```\n这里对数据流再做了一次封装，`counter` 记录了实际订阅的个数。如果 `counter` 为0，你就可以考虑清除它。\n\n### 还需要 Redux 吗？\n\n有一些解决方案，例如 redux-observable，Ngrx，都将 RxJs 与 Redux 结合在一起使用，他们结合得很好。\n\n但如果将 RxJs 仅是作为 Redux 的异步解决方案，而让视图层仍然与 Redux 接触，那其实前面说到的， RxJs 为我们带来的数据订阅，懒执行、无需单一 Store这样的特性其实就很难利用了。\n\n何况[通过 Rx 重新实现 Redux](https://github.com/jas-chen/rx-redux) 并不难。\n\n因此，我们完全有理由不使用 Redux。\n\n### 搭配 React\n\n如果不考虑使用 Redux，直接在 React 中订阅 RxJs 的数据流。如果你了解过 React-Hooks，可以使用 [React hooks for RxJS](https://github.com/LeetCode-OpenSource/rxjs-hooks)  这套方案。\n\n如果使用 React-Hooks 的方案，其底层实际使用的是 `useState` 方法，需要注意的是，这个 state 需要遵循不可变数据原则，如果对state对象进行了直接修改并返回同一对象，而不是复制数据，然后更新数据副本，`useState` 无效，React 会认为没有变化。因此，如果视图订阅的是单个数据项，可以将数据项另外存放在不可变的数组或者对象中，再提供给视图。\n\n如果坚持使用高阶组件的方式，实现一个 `connect()` 方法连接 React 与 RxJs 也不是什么难事。\n\n如果考虑在 React 中进行性能优化，这里提供两种选择：\n\n1. 对于单个数据流中，数据流动时，也需要遵循不可变数据原则，对于数据变换的部分，创建新的对象或者数组，以便于使用 `memo()` 进行浅层的判等检查，从而提升性能。\n\n    我们使用 RxJs 就是为了让变化的数据通过数据流流动，而不变化的数据不流动。结果到了 React 这里，我们却仍然需要关注不可变数据，是有那么一点点不太舒服。\n\n    但是好在我们做了范式化处理，数据项往往已经足够扁平，复制数据的操作并不会很繁琐。再加上 schema 这样的数据格式约定，完全可以自动完成这项操作，比如在更新数据的方法 `Store.prototype.upsert()` 中处理。\n\n2. 对提供给 React 订阅的数据流进行拆分。数据流中流动的数据，如果存储的是多层嵌套的数据，可以将被嵌套的数据也以数据流的形式提供给视图。例如，对于歌单，嵌套了歌曲列表的数据。视图 `<Playlist />` 订阅了数据流 `playlist$`，`playlist$` 中流动是歌单数据，其中以有序列表的形式嵌套了流动着歌曲类型的数据流 `track1$` - `trackN$`。由视图中的子组件 `<TrackItem />` 负责对其进行订阅。\n\n    ```js\n    const Playlist = () => {\n        const { payload = {} } = useObservable(() => playlist$);\n        const { views } = payload;\n        return (\n            <Name>{ payload.name }</Name>\n            <TrackList>\n                {\n                    views.tracks.map(track => <TrackItem track$={track.$} key={track.id} />)\n                }\n            </TrackList>\n        );\n    };\n\n    const TrackItem = ({ track$ }) => {\n        const data = useObservable(() => track$);\n        return (\n            <Name>{ data.name }</Name>\n        );\n    };\n    ```\n\n    这样可以一直分形下去，让每一级组件负责订阅自己所需的数据流。这样，`<Playlist />` 不再订阅歌曲项的数据流动，歌曲项的变化不会引起歌单自身区域的重新计算。但带来的问题是，每一级组件上都被数据流侵入，都出现了数据处理的逻辑，组件的 `props` 基本上仅剩下了一个数据流。视图层将不再轻量，所有组件需要基于数据流的思想进行改造，无法与其他基于 Redux 等框架的数据方案共用相同的组件。\n\n可以根据实际情况选择合适的方式，或者选择结合两种方式。\n\n## 总结\n\n- 万物皆可数据流\n- 多种方法组合数据流，直观描述数据计算、组合的逻辑\n- 订阅触发数据流动\n- 取消订阅考虑回收\n\n## 参考资料\n[复杂单页应用的数据层设计](https://zhuanlan.zhihu.com/p/24677176)\n\n[DaoCloud 基于 RxJS 的前端数据层实践](https://zhuanlan.zhihu.com/p/28958042)\n\n[像呼吸一样自然：React hooks + RxJS](https://zhuanlan.zhihu.com/p/50921147)"
        },
        {
          "id": "hot-vs-cold-observables",
          "metadata": {
            "permalink": "/hot-vs-cold-observables",
            "source": "@site/blog/hot-vs-cold-observables/index.md",
            "title": "Observable的冷与热",
            "description": "本文翻译自Hot vs Cold Observables",
            "date": "2019-11-01T10:00:00.000Z",
            "formattedDate": "2019年11月1日",
            "tags": [
              {
                "label": "rxjs",
                "permalink": "/tags/rxjs"
              },
              {
                "label": "javascript",
                "permalink": "/tags/javascript"
              }
            ],
            "readingTime": 9.82,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "hot-vs-cold-observables",
              "title": "Observable的冷与热",
              "authors": "auver",
              "date": "2019-11-01T10:00",
              "tags": [
                "rxjs",
                "javascript"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "云音乐桌面端基于 RxJs 的数据层探索",
              "permalink": "/rxjs-on-the-netease-cloud-music-desktop"
            },
            "nextItem": {
              "title": "巧用CSS遮罩",
              "permalink": "/css-mask"
            }
          },
          "content": "本文翻译自[Hot vs Cold Observables](https://benlesh.medium.com/hot-vs-cold-observables-f8094ed53339)\n\n\nCOLD 是指你的生产者在 observable 内部创建。\n\n```javascript\n// COLD\nvar cold = new Observable((observer) => {\n  var producer = new Producer();\n  // have observer listen to producer here\n});\n```\n\nHOT 是指当你的生产者在 observable 外部创建。\n\n```javascript\n// HOT\nvar producer = new Producer();\nvar hot = new Observable((observer) => {\n  // have observer listen to producer here\n});\n```\n\n<!-- truncate -->\n\n## 深入了解正在发生的事情...\n\n我的上一篇关于[通过构建 Observable 学习 Observable](https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87)的文章主要是为了说明 `observables` 只是函数。那篇文章的目标是揭开 `observables` 本身的神秘面纱，但它并没有深入探讨也许是最容易引起困惑的概念——`observables` 的“热”和“冷”。\n\n## Observables 只是函数！\n\nObservables 只是将观察者与生产者绑定的函数。它们不一定设置生产者，而是设置一个观察者来监听生产者，并通常返回一个方法以移除监听。`subscription ` 的行为就像调用一个函数，将观察者传递给它。\n\n## 什么是生产者 Producer？\n\n生产者 Producer 是您的 observable 的值来源。它可以是 WebSockets、DOM 事件、迭代器或循环遍历数组等任何用于获取值并将其传递给 `observer.next(value)` 的东西。\n\n## 冷 Observables：生产者在内部创建\n\n如果 observable 的底层的生产者是在订阅期间被创建并激活，则该 observable 是“cold”的。这意味着，如果 observables 是函数，那么通过调用该函数来创建和激活生产者。\n\n1. 创建生产者\n2. 激活生产者\n3. 开始监听生产者\n4. 单播\n\n下面的示例是“cold”的，因为它在订阅到 Observable 时，在订阅函数中创建并监听 WebSocket：\n\n```javascript\nconst source = new Observable((observer) => {\n  const socket = new WebSocket('ws://someurl');\n  socket.addEventListener('message', (e) => observer.next(e));\n  return () => socket.close();\n});\n```\n\n因此，订阅 `source` 的任何内容都将获得自己的 WebSocket 实例，并且在取消订阅时会关闭该 socket。这意味着我们的 source 实际上只能单播，因为生产者只能发送给一个 observer。\n\n## 热 Observables：生产者在外部创建\n\n如果 observable 的底层生产者在订阅之外被创建或激活，则该 observable 是热的[^1]。\n\n1. 共享对生产者的引用\n2. 开始监听生产者\n3. 多播（通常[^2]）\n\n如果我们将上面的示例中 WebSocket 的创建移至 observable 之外，它将变成热的：\n\n```javascript\nconst socket = new WebSocket('ws://someurl');\nconst source = new Observable((observer) => {\n  socket.addEventListener('message', (e) => observer.next(e));\n});\n```\n\n现在订阅 `source` 的任何内容都将共享相同的 WebSocket 实例。现在它实际上会多播给所有订阅者。但我们有一个小问题：我们不再跟踪对 `source` 的订阅，所以我们如何在需要时关闭它？我们可以添加一些引用计数来解决这个问题：\n\n```javascript\nconst socket = new WebSocket('ws://someurl');\nconst source = new Observable((observer) => {\n  socket.addEventListener('message', (e) => observer.next(e));\n});\n\nlet refs = 0;\nreturn new Observable((observer) => {\n  refs++;\n  let sub = source.subscribe(observer);\n  return () => {\n    refs--;\n    if (refs === 0) mainSub.unsubscribe();\n    sub.unsubscribe();\n  };\n});\n```\n\n现在我们有了一个热 observable，当所有对它的订阅结束时，我们使用引用计数来判断是否取消订阅底层源 observable。[这里有一个 JSBin 展示了这个基本概念](http://jsbin.com/godawic/edit?js%2Coutput=)。\n\n### Rx Subjects\n\n在我们将冷可观测对象转换为热可观测对象之前，首先需要介绍一种新类型：Rx Subject。它具有以下几个特点：\n\n1. 它是一个可观测对象。它形式上像一个可观测对象，并且具有相同的操作符。\n2. 它是一个观察者。它以观察者身份进行鸭子类型检查。当作为可观察对象进行订阅时，会发出任何通过 `next` 输入到其中的值。\n3. 它支持多播（multicast）。通过 `subscribe()` 添加到其中的所有观察者都会被添加到内部观察者列表中。\n4. Subject 在取消订阅、完成或出错后不能再重复使用。\n5. 它会将值传递给自己。再次强调第二点，在 Subject 中 `next` 输入值后会从其自身的可观察端口输出值。\n\nRx Subject 被称为 “subject”，因为上面提到的第三点。在 Gang Of Four [^译注1] 观察者模式中，“Subject” 可以视为具有 `addObserver` 方法的类，只不过使用的是 `subscribe` 方法作为我们的 `addObserver` 方法。[这里有一个展示 Rx Subject 基本行为的 JSBin。](http://jsbin.com/muziva/1/edit?js%2Coutput=)\n\n### 将冷可观测对象转换为热可观测对象\n\n有了上面介绍过的 Rx Subject，我们可以使用一些函数式编程方法将任何“冷”可观测对象转换为“热”可观测对象：\n\n```javascript\nfunction makeHot(cold) {\n  const subject = new Subject();\n  cold.subscribe(subject);\n  return new Observable((observer) => subject.subscribe(observer));\n}\n```\n\n我们的 `makeHot` 方法将接受任何冷可观测对象，并通过创建与结果可观测对象共享的主题来使其变成热可观测对象。[这里展示了此方法运行结果。](http://jsbin.com/ketodu/1/edit?js%2Coutput=)\n\n然而，还存在一个小问题：我们没有跟踪对源（source）进行订阅，那么我们如何在需要时取消对其进行取消订阅？我们可以添加一些引用计数来解决这个问题：\n\n```javascript\nfunction makeHotRefCounted(cold) {\n  const subject = new Subject();\n  const mainSub = cold.subscribe(subject);\n  let refs = 0;\n  \n  return new Observable((observer) => {\n    refs++;\n    let sub = subject.subscribe(observer);\n    return () => {\n      refs--;\n      if (refs === 0)\n        mainSub.unsubscribe();\n      sub.unsubscribe();\n    };\n  });\n}\n```\n\n现在我们有了一个既热又使用引用计数来跟踪源（source）取消订阅情况的可观测对象。[这里展示了此方法运行结果。](http://jsbin.com/lubata/1/edit?js%2Coutput=)\n\n### 在 RxJS 中使用 `publish()` 或 `share()`\n\n您可能不应该使用上面提到过的任何 `makeHot` 函数，而应该使用像 `publish()` 和 `share()` 这样的操作符。在 Rx 中有很多方法可以使冷可观测对象变成热可观测对象，并且每种方法都能高效且简洁地执行每种操作所需工作。关于此主题，在 Rx 中使用各种操作符进行详细介绍可能需要写一篇完整文章，但本文不涉及此目标。本文旨在明确 “hot” 和 “cold” 的真正含义。\n\n在 RxJS5 中，“share()” 操作符会生成一个热且具备引用计数功能（refCounted）以便在失败时重试或成功后重复执行操作序列（observable）。由于 subjects 在错误、完成或取消订阅后无法再次使用，“share()” 操作符会重新利用已结束（dead）subjects 来允许重新对生成的observable 进行重复订阅。\n\n### “温暖”的 Observable\n\n鉴于以上所有内容，也许您可以看出一个 observable 其实既可以是“hot”，也可以是“cold”。也就是说它同时侦听两个 producers？一个由其自身创建和另一个闭包？那可能不太好...但也有极少数情况下可能会需要这样做。例如多路复用 web socket 必须共享 socket，并发送自己专属 subscription 并过滤数据流。\n\n### “Hot” 和 “Cold” 都与 Producer 相关\n\n如果您闭包了共享引用以侦听 producer，则该 observable 是“hot”的；如果您在 observable 内部创建新 producer，则该 observable 是“cold”的；如果两者都做...那您到底做什么呢？我想那就是“温暖”的吧。\n\n[^1]:（注意：说 producer 在 subscription 内部被 “activated”，但直到稍后某个时间点才被 “created”，似乎有点奇怪；但借助代理（proxies），可能还真能实现）。通常情况下，“hot” observables 的 producers 同时被创建和激活外部 subscription。\n\n[^2]: 热 observables 通常支持多播（multicast），但它们可能正在监听只支持一次监听器的 producer 上发生事件流动情况下；此时称之为 “multicast” 的依据略微模糊。\n\n[^译注1]: \\<Design Patterns\\> 这本书的作者被称为 Gang of Four “四人帮”"
        },
        {
          "id": "css-mask",
          "metadata": {
            "permalink": "/css-mask",
            "source": "@site/blog/css-mask/index.md",
            "title": "巧用CSS遮罩",
            "description": "1. 用法 ##",
            "date": "2016-12-01T10:00:00.000Z",
            "formattedDate": "2016年12月1日",
            "tags": [
              {
                "label": "css",
                "permalink": "/tags/css"
              }
            ],
            "readingTime": 3.44,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Auver",
                "title": "全干工程师",
                "url": "https://github.com/auver",
                "imageURL": "https://github.com/auver.png",
                "key": "auver"
              }
            ],
            "frontMatter": {
              "slug": "css-mask",
              "title": "巧用CSS遮罩",
              "authors": "auver",
              "date": "2016-12-01T10:00",
              "tags": [
                "css"
              ]
            },
            "unlisted": false,
            "prevItem": {
              "title": "Observable的冷与热",
              "permalink": "/hot-vs-cold-observables"
            }
          },
          "content": "## 1. 用法 ##\n-webkit-mask样式是利用该属性指定的图片作为遮罩，利用这张图像的透明度来显示位于该遮罩图下方的图像。如果遮罩图某个像素点透明度为1则显示下方的图像，透明度为0则不显示，介于0-1之间则呈现相应的透明度。\n详情参考 [mask - CSS | MDN][1]\n可以看到，mask的语法基本上拷贝自background，可以设置遮罩的url, position, repeat, size等属性，但不能直接设置颜色（纯色的遮罩意味着用opacity就能实现）。-webkit-mask-url可以设置gradients的渐变图片，也可以设置base64编码的图片。\n## 2. 利用mask实现图标变色 ##\n想让图标可以任意变色，常见的方案有：font-awesome, SVG等，甚至还有[drop-shadow][2]。其实可以利用background变色，而利用遮罩去绘制图标。遮罩透过的地方是图标的填色部分，而遮罩盖过的地方则没有颜色。\n这种方法的优点就是转换成本极低，可以直接利用已有的图标PNG图。具体方法如下：\n\n - 将图标保存为PNG图，注意非图标区域应该是透明的。如果原有图标是sprite图，没关系，不用变，因为mask支持position属性。原先输出的图标不是纯黑色的？也没关系，因为mask样式只认你图片的透明通道\n\n - 设置图标的CSS，例如：\n\n<!-- truncate -->\n\n```css\n.m-mask{\n\twidth:141px;\n\theight:141px;\n\t-webkit-mask-image: url(mask.png);\n\tbackground: #3f51b5;\n}\n```\n  \n - 这样就好了，效果如下\n\n![link](./link.png)\n\n完全可以把此时的background-color理解成Photoshop中的颜色叠加\n\n![ps](./ps.png)\n\n如果结合less sass，就可以做到自定义换肤了\n## 3.利用mask修复圆角头像的毛边 ##\n在实际的开发过程中，发现在较高版本的Chrome浏览器中，我们的圆角头像出现了无法容忍的毛边，定位到问题的原因是这样的：外层div利用background设置了垫底的默认图，设置了border-radius:50%。而内层的img为实际头像图，也设置了border-radius:50%。理论上两个相等大小、相同圆角的元素，也未设置任何定位，那么应该是头像完整盖着默认图。但实际并未如此，而是头像略小于默认图，因而出现了毛边。\n\n![avatar](./avatar.jpg)\n\n因此我们可以为外层div添加一个样式\n```\n-webkit-mask-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==')\n```\nurl中设置的其实是1像素高宽的黑色图片，那么此时的遮罩就相当于外层div设置圆角区域后的一个不透明的圆形。此时就可以去掉img上的boder-radius了。最后效果如下，完美！\n\n![avatar](./avatar.png)\n\n\n  [1]: https://developer.mozilla.org/en-US/docs/Web/CSS/mask\n  [2]: http://www.zhangxinxu.com/wordpress/2016/06/png-icon-change-color-by-css/"
        }
      ],
      "blogListPaginated": [
        {
          "items": [
            "sourcemap",
            "babel-plugin",
            "rxjs-ipc",
            "electron-apps-automatically-update",
            "react-hooks-best-practices",
            "rxjs-on-the-netease-cloud-music-desktop",
            "hot-vs-cold-observables",
            "css-mask"
          ],
          "metadata": {
            "permalink": "/",
            "page": 1,
            "postsPerPage": 10,
            "totalPages": 1,
            "totalCount": 8,
            "blogDescription": "Blog",
            "blogTitle": "Blog"
          }
        }
      ],
      "blogTags": {
        "/tags/sourcemap": {
          "label": "sourcemap",
          "items": [
            "sourcemap"
          ],
          "permalink": "/tags/sourcemap",
          "pages": [
            {
              "items": [
                "sourcemap"
              ],
              "metadata": {
                "permalink": "/tags/sourcemap",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/javascript": {
          "label": "javascript",
          "items": [
            "sourcemap",
            "babel-plugin",
            "rxjs-ipc",
            "react-hooks-best-practices",
            "rxjs-on-the-netease-cloud-music-desktop",
            "hot-vs-cold-observables"
          ],
          "permalink": "/tags/javascript",
          "pages": [
            {
              "items": [
                "sourcemap",
                "babel-plugin",
                "rxjs-ipc",
                "react-hooks-best-practices",
                "rxjs-on-the-netease-cloud-music-desktop",
                "hot-vs-cold-observables"
              ],
              "metadata": {
                "permalink": "/tags/javascript",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 6,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/babel": {
          "label": "babel",
          "items": [
            "babel-plugin"
          ],
          "permalink": "/tags/babel",
          "pages": [
            {
              "items": [
                "babel-plugin"
              ],
              "metadata": {
                "permalink": "/tags/babel",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/ast": {
          "label": "ast",
          "items": [
            "babel-plugin"
          ],
          "permalink": "/tags/ast",
          "pages": [
            {
              "items": [
                "babel-plugin"
              ],
              "metadata": {
                "permalink": "/tags/ast",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/rxjs": {
          "label": "rxjs",
          "items": [
            "rxjs-ipc",
            "rxjs-on-the-netease-cloud-music-desktop",
            "hot-vs-cold-observables"
          ],
          "permalink": "/tags/rxjs",
          "pages": [
            {
              "items": [
                "rxjs-ipc",
                "rxjs-on-the-netease-cloud-music-desktop",
                "hot-vs-cold-observables"
              ],
              "metadata": {
                "permalink": "/tags/rxjs",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 3,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/electron": {
          "label": "electron",
          "items": [
            "electron-apps-automatically-update"
          ],
          "permalink": "/tags/electron",
          "pages": [
            {
              "items": [
                "electron-apps-automatically-update"
              ],
              "metadata": {
                "permalink": "/tags/electron",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/hooks": {
          "label": "hooks",
          "items": [
            "react-hooks-best-practices"
          ],
          "permalink": "/tags/hooks",
          "pages": [
            {
              "items": [
                "react-hooks-best-practices"
              ],
              "metadata": {
                "permalink": "/tags/hooks",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/react": {
          "label": "react",
          "items": [
            "react-hooks-best-practices"
          ],
          "permalink": "/tags/react",
          "pages": [
            {
              "items": [
                "react-hooks-best-practices"
              ],
              "metadata": {
                "permalink": "/tags/react",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        },
        "/tags/css": {
          "label": "css",
          "items": [
            "css-mask"
          ],
          "permalink": "/tags/css",
          "pages": [
            {
              "items": [
                "css-mask"
              ],
              "metadata": {
                "permalink": "/tags/css",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ],
          "unlisted": false
        }
      },
      "blogTagsListPath": "/tags"
    }
  },
  "docusaurus-plugin-content-pages": {
    "default": null
  },
  "docusaurus-plugin-debug": {},
  "docusaurus-theme-classic": {},
  "docusaurus-bootstrap-plugin": {},
  "docusaurus-mdx-fallback-plugin": {}
}